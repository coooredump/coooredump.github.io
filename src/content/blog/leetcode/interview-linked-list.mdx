---
title: é«˜é¢‘ã€Œé“¾è¡¨ã€é¢è¯•é¢˜
description: é¢è¯•é«˜é¢‘è€ƒç‚¹ä¹‹é“¾è¡¨é¢˜
publishDate: 2025-04-28
tags: [leetcode]
heroImage: { src: ../_img/202501222250241.jpeg }
language: Chinese
comment: true
draft: false
---

## âœ… é«˜é¢‘é“¾è¡¨é¢è¯•é¢˜

ç›¸å…³ä¾‹é¢˜ï¼š

- [141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)
- [142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)
- [160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
- [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)
- [92. åè½¬é“¾è¡¨ II](https://leetcode.cn/problems/reverse-linked-list-ii/)
- [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)
- [234. å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/)
- [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)
- [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)
- [445. ä¸¤æ•°ç›¸åŠ  II](https://leetcode.cn/problems/add-two-numbers-ii/)
- [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
- [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)
- [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
- [23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)
- [146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)
- [138. éšæœºé“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/copy-list-with-random-pointer/)
- ...
- [82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
- [61. æ—‹è½¬é“¾è¡¨](https://leetcode.cn/problems/rotate-list/)
- [86. åˆ†éš”é“¾è¡¨](https://leetcode.cn/problems/partition-list/)
- [148. æ’åºé“¾è¡¨](https://leetcode.cn/problems/sort-list/)

## [141. ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280121512.png)

```cpp
è¾“å…¥ï¼šhead = [3,2,0,-4], pos = 1
è¾“å‡ºï¼štrue
è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚
```

### 1ï¸âƒ£ å¿«æ…¢æŒ‡é’ˆ

```cpp
class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
                return true;
        }
        return false;
    }
};
```

## [142. ç¯å½¢é“¾è¡¨ II](https://leetcode.cn/problems/linked-list-cycle-ii/)

ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹  `head` ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ *å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› `null`ã€‚*

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª `next` æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° `pos` æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆ**ç´¢å¼•ä» 0 å¼€å§‹**ï¼‰ã€‚å¦‚æœ `pos` æ˜¯ `-1`ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚**æ³¨æ„ï¼š`pos` ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’**ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

**ä¸å…è®¸ä¿®æ”¹** é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280119476.png)

```cpp
è¾“å…¥ï¼šhead = [3,2,0,-4], pos = 1
è¾“å‡ºï¼šè¿”å›ç´¢å¼•ä¸º 1 çš„é“¾è¡¨èŠ‚ç‚¹
è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚
```

### 1ï¸âƒ£ å¿«æ…¢æŒ‡é’ˆ

![fig1](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280121614.png)

```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                // a = k(b + c) + c
                ListNode* node = head;
                while (node != slow) {
                    node = node->next;
                    slow = slow->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```

## [160. ç›¸äº¤é“¾è¡¨](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280122571.png)

```cpp
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        ListNode *p = headA, *q = headB;
        while (p != q) {
            p = p ? p->next : headB;
            q = q ? q->next : headA;
        }
        return p;
    }
};
```

## [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280123470.jpg)

### 1ï¸âƒ£ è¿­ä»£ï½œä¸‰æŒ‡é’ˆ

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```

### 2ï¸âƒ£ é€’å½’

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)
            return head;
        ListNode* new_head = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;   // ä¸ºäº†åè½¬åçš„æœ«èŠ‚ç‚¹
        return new_head;
    }
};
```

## [92. åè½¬é“¾è¡¨ II](https://leetcode.cn/problems/reverse-linked-list-ii/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280141581.jpg)

åè½¬é“¾è¡¨è¿›é˜¶ï¼šåè½¬éƒ¨åˆ†åŒºé—´ï¼Œæ‰¾åˆ°åŒºé—´ leftNode ä¸ rightNodeï¼Œä»¥åŠ leftNode å·¦èŠ‚ç‚¹ pre ä¸ rightNode å³èŠ‚ç‚¹ nxtï¼Œç‹¬ç«‹åŒºé—´ï¼ˆæ–­å¼€è¿æ¥ï¼‰ååè½¬å†æ¥å›ã€‚

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* pre = &dummy;
        int t = left;
        while (--t) {
            pre = pre->next;
        }
        ListNode* leftNode = pre->next;
        ListNode* rightNode = leftNode;
        t = right - left;
        while (t--) {
            rightNode = rightNode->next;
        }
        ListNode* nxt = rightNode->next;
        // æ–­å¼€é“¾æ¥
        pre->next = nullptr;
        rightNode->next = nullptr;
        // åè½¬é“¾è¡¨
        ListNode* node = reverseList(leftNode);
        // é‡æ–°é“¾æ¥
        pre->next = node;
        leftNode->next = nxt;
        return dummy.next;
    }
};
```

## [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280127329.jpg)

```cpp
è¾“å…¥ï¼šhead = [1,2,3,4,5]
è¾“å‡ºï¼š[3,4,5]
è§£é‡Šï¼šé“¾è¡¨åªæœ‰ä¸€ä¸ªä¸­é—´ç»“ç‚¹ï¼Œå€¼ä¸º 3 ã€‚
```

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280127215.jpg)

```cpp
è¾“å…¥ï¼šhead = [1,2,3,4,5,6]
è¾“å‡ºï¼š[4,5,6]
è§£é‡Šï¼šè¯¥é“¾è¡¨æœ‰ä¸¤ä¸ªä¸­é—´ç»“ç‚¹ï¼Œå€¼åˆ†åˆ«ä¸º 3 å’Œ 4 ï¼Œè¿”å›ç¬¬äºŒä¸ªç»“ç‚¹ã€‚
```

### 1ï¸âƒ£ å¿«æ…¢æŒ‡é’ˆ

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

## [234. å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280125316.jpg)

### 1ï¸âƒ£ å›æ–‡é“¾è¡¨åˆ¤æ–­ = å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹ + åè½¬é“¾è¡¨

å‰ç½®é¢˜ç›®ï¼š

- [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)
- [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr, *cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    bool isPalindrome(ListNode* head) {
        ListNode* mid = middleNode(head);
        ListNode* head2 = reverseList(mid);
        while (head2) {
            if (head->val != head2->val) {
                return false;
            }
            head = head->next;
            head2 = head2->next;
        }
        return true;
    }
};
```

## [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280128941.jpg)

```cpp
è¾“å…¥ï¼šl1 = [1,2,4], l2 = [1,3,4]
è¾“å‡ºï¼š[1,1,2,3,4,4]
```

### 1ï¸âƒ£ è¿­ä»£ï¼ˆå¸¸ç”¨ï¼‰

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{};
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }
};
```

### 2ï¸âƒ£ é€’å½’

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) return list2; // æ³¨ï¼šå¦‚æœéƒ½ä¸ºç©ºåˆ™è¿”å›ç©º
        if (list2 == nullptr) return list1;
        if (list1->val < list2->val) {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        }
        list2->next = mergeTwoLists(list1, list2->next);
        return list2;
    }
};
```

## [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)ï½œä»å¤´å¼€å§‹ç›¸åŠ 

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280130500.jpg)

### 1ï¸âƒ£ è¿­ä»£

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy;
        ListNode* cur = &dummy;
        int carry = 0;
        while (l1 || l2 || carry) {
            if (l1) {
                carry += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                carry += l2->val;
                l2 = l2->next;
            }
            cur = cur->next = new ListNode(carry % 10);
            carry /= 10;
        }
        return dummy.next;
    }
};
```

### 2ï¸âƒ£ é€’å½’

```cpp
class Solution {
public:
    // l1 å’Œ l2 ä¸ºå½“å‰éå†çš„èŠ‚ç‚¹ï¼Œcarry ä¸ºè¿›ä½
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry = 0) {
        if (l1 == nullptr && l2 == nullptr) { // é€’å½’è¾¹ç•Œï¼šl1 å’Œ l2 éƒ½æ˜¯ç©ºèŠ‚ç‚¹
            return carry ? new ListNode(carry) : nullptr; // å¦‚æœè¿›ä½äº†ï¼Œå°±é¢å¤–åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹
        }
        if (l1 == nullptr) { // å¦‚æœ l1 æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ­¤æ—¶ l2 ä¸€å®šä¸æ˜¯ç©ºèŠ‚ç‚¹
            swap(l1, l2); // äº¤æ¢ l1 ä¸ l2ï¼Œä¿è¯ l1 éç©ºï¼Œä»è€Œç®€åŒ–ä»£ç 
        }
        int sum = carry + l1->val + (l2 ? l2->val : 0); // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
        l1->val = sum % 10; // æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªæ•°ä½ï¼ˆç›´æ¥ä¿®æ”¹åŸé“¾è¡¨ï¼‰
        l1->next = addTwoNumbers(l1->next, (l2 ? l2->next : nullptr), sum / 10); // è¿›ä½
        return l1;
    }
};
```

## [445. ä¸¤æ•°ç›¸åŠ  II](https://leetcode.cn/problems/add-two-numbers-ii/)ï½œä»å°¾å¼€å§‹ç›¸åŠ 

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280132912.png)

### 1ï¸âƒ£ è¿­ä»£ï½œåè½¬é“¾è¡¨ + ä¸¤æ•°ç›¸åŠ 

```cpp
class Solution {
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, *cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    ListNode* addTwo(ListNode* l1, ListNode* l2) {
        ListNode dummy; // å“¨å…µèŠ‚ç‚¹
        auto cur = &dummy;
        int carry = 0; // è¿›ä½
        while (l1 || l2 || carry) { // æœ‰ä¸€ä¸ªä¸æ˜¯ç©ºèŠ‚ç‚¹ï¼Œæˆ–è€…è¿˜æœ‰è¿›ä½ï¼Œå°±ç»§ç»­è¿­ä»£
            if (l1) carry += l1->val; // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
            if (l2) carry += l2->val; // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
            cur = cur->next = new ListNode(carry % 10); // æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªæ•°ä½
            carry /= 10; // æ–°çš„è¿›ä½
            if (l1) l1 = l1->next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            if (l2) l2 = l2->next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }
        return dummy.next; // å“¨å…µèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å¤´èŠ‚ç‚¹
    }

public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2);
        auto l3 = addTwo(l1, l2);
        return reverseList(l3);
    }
};
```

### 2ï¸âƒ£ é€’å½’ï½œåè½¬é“¾è¡¨ + ä¸¤æ•°ç›¸åŠ 

```cpp
class Solution {
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        auto new_head = reverseList(head->next);
        head->next->next = head; // æŠŠä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘è‡ªå·±
        head->next = nullptr; // æ–­å¼€æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„è¿æ¥ï¼Œä¿è¯æœ€ç»ˆé“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹çš„ next æ˜¯ç©ºèŠ‚ç‚¹
        return new_head;
    }

    // l1 å’Œ l2 ä¸ºå½“å‰éå†çš„èŠ‚ç‚¹ï¼Œcarry ä¸ºè¿›ä½
    ListNode* addTwo(ListNode* l1, ListNode* l2, int carry = 0) {
        if (l1 == nullptr && l2 == nullptr) { // é€’å½’è¾¹ç•Œï¼šl1 å’Œ l2 éƒ½æ˜¯ç©ºèŠ‚ç‚¹
            return carry ? new ListNode(carry) : nullptr; // å¦‚æœè¿›ä½äº†ï¼Œå°±é¢å¤–åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹
        }
        if (l1 == nullptr) { // å¦‚æœ l1 æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ­¤æ—¶ l2 ä¸€å®šä¸æ˜¯ç©ºèŠ‚ç‚¹
            swap(l1, l2); // äº¤æ¢ l1 ä¸ l2ï¼Œä¿è¯ l1 éç©ºï¼Œä»è€Œç®€åŒ–ä»£ç 
        }
        carry += l1->val + (l2 ? l2->val : 0); // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
        l1->val = carry % 10; // æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªæ•°ä½
        l1->next = addTwo(l1->next, (l2 ? l2->next : nullptr), carry / 10); // è¿›ä½
        return l1;
    }

public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2); // l1 å’Œ l2 åè½¬åï¼Œå°±å˜æˆã€2. ä¸¤æ•°ç›¸åŠ ã€‘äº†
        auto l3 = addTwo(l1, l2);
        return reverseList(l3);
    }
};
```

## [19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280135230.jpg)

### 1ï¸âƒ£ å¿«æ…¢æŒ‡é’ˆ

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy(0, head);
        ListNode *fast = &dummy, *slow = &dummy;
        while (n--) {
            fast = fast->next;
        }
        while (fast->next) {
            slow = slow->next;
            fast = fast->next;
        }
        ListNode* d = slow->next;
        slow->next = d->next;
        delete d;
        return dummy.next;
    }
};
```

## [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280137405.jpg)

### 1ï¸âƒ£ è¿­ä»£ï½œå››æŒ‡é’ˆ

![lc24-c.png](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280137375.png)

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode dummy(0, head); // ç”¨å“¨å…µèŠ‚ç‚¹ç®€åŒ–ä»£ç é€»è¾‘
        ListNode* node0 = &dummy;
        ListNode* node1 = head;
        while (node1 && node1->next) { // è‡³å°‘æœ‰ä¸¤ä¸ªèŠ‚ç‚¹
            ListNode* node2 = node1->next;
            ListNode* node3 = node2->next;

            node0->next = node2; // 0 -> 2
            node2->next = node1; // 2 -> 1
            node1->next = node3; // 1 -> 3

            node0 = node1; // ä¸‹ä¸€è½®äº¤æ¢ï¼Œ0 æ˜¯ 1
            node1 = node3; // ä¸‹ä¸€è½®äº¤æ¢ï¼Œ1 æ˜¯ 3
        }
        return dummy.next; // è¿”å›æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹
    }
};
```

### 2ï¸âƒ£ é€’å½’

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        ListNode* node1 = head;
        ListNode* node2 = head->next;
        ListNode* node3 = node2->next;

        node1->next = swapPairs(node3); // 1 æŒ‡å‘é€’å½’è¿”å›çš„é“¾è¡¨å¤´
        node2->next = node1; // 2 æŒ‡å‘ 1

        return node2; // è¿”å›äº¤æ¢åçš„é“¾è¡¨å¤´èŠ‚ç‚¹
    }
};
```

## [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280139936.jpg)

### 1ï¸âƒ£ ä»ã€Œåè½¬é“¾è¡¨ Â· è¿­ä»£ç‰ˆã€åˆ°ã€ŒK ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ã€

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        int n = 0;
        for (ListNode* cur = head; cur; cur = cur->next) {
            n++;
        }
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        ListNode* prev = nullptr;
        ListNode* cur = head;
        for (; n >= k; n -= k) {
            for (int i = 0; i < k; i++) {
                ListNode* nxt = cur->next;
                cur->next = prev;
                prev = cur;
                cur = nxt;
            }
            ListNode* last = p0->next;
            p0->next = prev;
            last->next = cur;
            p0 = last;
        }
        return dummy.next;
    }
};
```

### 2ï¸âƒ£ã€Œ206. åè½¬é“¾è¡¨ã€+ã€Œ92. åè½¬é“¾è¡¨ IIã€

```cpp
class Solution {
public:
    // 206. åè½¬é“¾è¡¨
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    // 92. åè½¬é“¾è¡¨ II
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* pre = &dummy;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }
        ListNode* leftNode = pre->next;
        ListNode* rightNode = leftNode;
        for (int i = left; i < right; i++) {
            rightNode = rightNode->next;
        }
        ListNode* nxt = rightNode->next;
        rightNode->next = nullptr;
        reverseList(leftNode);
        pre->next = rightNode;
        leftNode->next = nxt;
        return dummy.next;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        int n = 0;
        ListNode* cur = head;
        while (cur) {
            n++;
            cur = cur->next;
        }
        if (n < k) {
            return head;
        }
        ListNode* new_head = head;
        int times = n / k;
        for (int i = 0; times--; i += k) {
            ListNode* node = reverseBetween(new_head, i + 1, i + k);
            if (i == 0) {
                new_head = node;
            }
        }
        return new_head;
    }
};
```

## [23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)

```cpp
è¾“å…¥ï¼šlists = [[1,4,5],[1,3,4],[2,6]]
è¾“å‡ºï¼š[1,1,2,3,4,4,5,6]
è§£é‡Šï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š
[
  1->4->5,
  1->3->4,
  2->6
]
å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚
1->1->2->3->4->4->5->6
```

âœ… **å¿«æ‰‹ä¸€é¢**ï¼Œé¢è¯•å®˜æ¥ä¸€é¢˜ç®€å•é¢˜ğŸ˜Šï¼Œæœ€åè¿˜é—®äº†æ—¶é—´å¤æ‚åº¦ï¼šå‡è®¾ k ä¸ªé“¾è¡¨ï¼Œå…± n ä¸ªèŠ‚ç‚¹ï¼Œé‚£æ—¶é—´å¤æ‚åº¦ä¸º $O(kÂ·logk+nÂ·logk)$ å³ $O(nÂ·logk)$ã€‚

### 1ï¸âƒ£ æœ€å°å †

æ—¶é—´å¤æ‚åº¦åˆ†æï¼šå‡è®¾ $k$ ä¸ªé“¾è¡¨, å…± $n$ ä¸ªèŠ‚ç‚¹, æœ€å°å †å•æ¬¡æ“ä½œ $O(log k)$, åˆå§‹åŒ–å †éœ€è¦ $O(kÂ·logk)$, é‚£æ—¶é—´å¤æ‚åº¦ä¸º $O(kÂ·logk + nÂ·logk)$ï¼Œå³ $O(nÂ·logk)$ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](const ListNode* a, const ListNode* b) {
            return a->val > b->val;
        };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto& head : lists) {
            if (head) {
                pq.push(head);
            }
        }
        ListNode dummy{};
        ListNode* head = &dummy;
        while (!pq.empty()) {
            ListNode* node = pq.top();
            pq.pop();
            head->next = node;
            head = head->next;
            if (node->next)
                pq.push(node->next);
        }
        return dummy.next;
    }
};
```

### 2ï¸âƒ£ åˆ†æ²»æ³•

å‰ç½®é¢˜ç›®ï¼š[21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{};
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists, int l, int r) {
        if (l == r)
            return lists[l];
        if (l > r)
            return nullptr;
        int m = (l + r) >> 1;
        auto left = mergeKLists(lists, l, m);
        auto right = mergeKLists(lists, m + 1, r);
        return mergeTwoLists(left, right);
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return mergeKLists(lists, 0, lists.size() - 1);
    }
};
```

## [146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)

![å›¾è§£ LRU](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280145436.png)

```cpp
struct Node {
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LRUCache {
private:
    Node* dummy;
    int capacity;
    unordered_map<int, Node*> key_to_node;

    void remove(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void push_front(Node* node) {
        node->next = dummy->next;
        node->prev = dummy;
        dummy->next->prev = node;
        dummy->next = node;
    }

    Node* get_node(int key) {
        if (!key_to_node.count(key)) {
            return nullptr;
        }
        Node* node = key_to_node[key];
        remove(node);
        push_front(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
        dummy->next = dummy;
        dummy->prev = dummy;
    }

    int get(int key) {
        Node* node = get_node(key);
        return node == nullptr ? -1 : node->value;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node != nullptr) {
            node->value = value;
            return;
        }
        node = new Node(key, value);
        if (key_to_node.size() == capacity) {
            Node* last = dummy->prev;
            remove(last);
            key_to_node.erase(last->key);
            delete last;
        }
        key_to_node[key] = node;
        push_front(node);
    }
};
```

## [138. éšæœºé“¾è¡¨çš„å¤åˆ¶](https://leetcode.cn/problems/copy-list-with-random-pointer/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280147716.png)

```cpp
è¾“å…¥ï¼šhead = [[7,null],[13,0],[11,4],[10,2],[1,0]]
è¾“å‡ºï¼š[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;

    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    unordered_map<Node*, Node*> cacheNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr)
            return nullptr;
        if (!cacheNode.count(head)) {
            Node* newHead = new Node(head->val);
            cacheNode[head] = newHead;
            newHead->next = copyRandomList(head->next);
            newHead->random = copyRandomList(head->random);
        }
        return cacheNode[head];
    }
};
```

## [82. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

ç»™å®šä¸€ä¸ªå·²æ’åºçš„é“¾è¡¨çš„å¤´ `head` ï¼Œ *åˆ é™¤åŸå§‹é“¾è¡¨ä¸­æ‰€æœ‰é‡å¤æ•°å­—çš„èŠ‚ç‚¹ï¼Œåªç•™ä¸‹ä¸åŒçš„æ•°å­—* ã€‚è¿”å› *å·²æ’åºçš„é“¾è¡¨* ã€‚

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280148574.jpg)

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy(0, head);
        auto cur = &dummy;
        while (cur->next && cur->next->next) {
            int val = cur->next->val;
            if (cur->next->next->val == val) {
                while (cur->next && cur->next->val == val) {
                    cur->next = cur->next->next;
                }
            } else {
                cur = cur->next;
            }
        }
        return dummy.next;
    }
};
```

## [61. æ—‹è½¬é“¾è¡¨](https://leetcode.cn/problems/rotate-list/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œæ—‹è½¬é“¾è¡¨ï¼Œå°†é“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹å‘å³ç§»åŠ¨ `k` ä¸ªä½ç½®ã€‚

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280149901.jpg)

```cpp
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
è¾“å‡ºï¼š[4,5,1,2,3]
```

æ€è·¯ï¼šæˆ‘ä»¬å¯ä»¥å…ˆå°†ç»™å®šçš„é“¾è¡¨è¿æ¥æˆç¯ï¼Œç„¶åå°†æŒ‡å®šä½ç½®æ–­å¼€ã€‚

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (k == 0 || !head || !head->next) {
            return head;
        }
        int n = 1;
        ListNode* iter = head;
        while (iter->next) {
            iter = iter->next;
            n++;
        }
        int t = n - k % n;
        if (t == n)
            return head;
        iter->next = head; // è¿æˆç¯
        while (t--) {
            iter = iter->next;
        }
        ListNode* ret = iter->next;
        iter->next = nullptr;
        return ret;
    }
};
```

## [86. åˆ†éš”é“¾è¡¨](https://leetcode.cn/problems/partition-list/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` å’Œä¸€ä¸ªç‰¹å®šå€¼ `x` ï¼Œè¯·ä½ å¯¹é“¾è¡¨è¿›è¡Œåˆ†éš”ï¼Œä½¿å¾—æ‰€æœ‰ **å°äº** `x` çš„èŠ‚ç‚¹éƒ½å‡ºç°åœ¨ **å¤§äºæˆ–ç­‰äº** `x` çš„èŠ‚ç‚¹ä¹‹å‰ã€‚

ä½ åº”å½“ **ä¿ç•™** ä¸¤ä¸ªåˆ†åŒºä¸­æ¯ä¸ªèŠ‚ç‚¹çš„åˆå§‹ç›¸å¯¹ä½ç½®ã€‚

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280150286.jpg)

```cpp
è¾“å…¥ï¼šhead = [1,4,3,2,5,2], x = 3
è¾“å‡ºï¼š[1,2,2,4,3,5]
```

### 1ï¸âƒ£ æ¨¡æ‹Ÿ

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode largeDummy(0);
        ListNode* large = &largeDummy;
        ListNode smallDummy(0);
        ListNode* small = &smallDummy;
        while (head) {
            if (head->val < x) {
                small->next = head;
                small = small->next;
            } else {
                large->next = head;
                large = large->next;
            }
            head = head->next;
        }
        small->next = largeDummy.next;
        large->next = nullptr;
        return smallDummy.next;
    }
};
```

## [148. æ’åºé“¾è¡¨](https://leetcode.cn/problems/sort-list/)

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504280151182.jpg)

### 1ï¸âƒ£ å½’å¹¶æ’åºï¼ˆåˆ†æ²»æ³•ï¼‰ï½œé“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ + åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

```cpp
class Solution {
public:
    // 876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ï¼ˆå¿«æ…¢æŒ‡é’ˆï¼‰
    ListNode* middleNode(ListNode* head) {
        ListNode* pre = head;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        pre->next = nullptr; // æ–­å¼€ slow ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹çš„è¿æ¥
        return slow;
    }

    // 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ (åŒæŒ‡é’ˆ)
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy;
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }

    ListNode* sortList(ListNode* head) {
        if (!head || !head->next)
            return head;
        ListNode* mid = middleNode(head);
        ListNode* head1 = sortList(head);
        ListNode* head2 = sortList(mid);
        return mergeTwoLists(head1, head2);
    }
};
```