---
title: å¿«æ‰‹ä¸€é¢ï½œåˆå¹¶ K ä¸ªå‡åºé“¾è¡¨
description: å¿«æ‰‹ä¸€é¢ï¼Œé¢è¯•å®˜è¯´æ¥ä¸€é¢˜ç®€å•é¢˜ï¼Œæœ€åè¿˜é—®äº†æ—¶é—´å¤æ‚åº¦ï¼šå‡è®¾ k ä¸ªé“¾è¡¨ï¼Œå…± n ä¸ªèŠ‚ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘
publishDate: 2025-04-28
tags: [leetcode]
heroImage: { src: ../_img/202501222250241.jpeg }
language: Chinese
comment: true
draft: false
---

## å¿«æ‰‹ä¸€é¢ & æ—¶é—´å¤æ‚åº¦

**å¿«æ‰‹ä¸€é¢**ï¼Œé¢è¯•å®˜è¯´æ¥ä¸€é¢˜ç®€å•é¢˜ğŸ˜Šï¼Œæœ€åè¿˜é—®äº†æ—¶é—´å¤æ‚åº¦ï¼šå‡è®¾ k ä¸ªé“¾è¡¨ï¼Œå…± n ä¸ªèŠ‚ç‚¹ï¼Œé‚£æ—¶é—´å¤æ‚åº¦ä¸º $O(kÂ·logk+nÂ·logk)$ å³ $O(nÂ·logk)$ã€‚

## [23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

```cpp
è¾“å…¥ï¼šlists = [[1,4,5],[1,3,4],[2,6]]
è¾“å‡ºï¼š[1,1,2,3,4,4,5,6]
è§£é‡Šï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š
[
  1->4->5,
  1->3->4,
  2->6
]
å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚
1->1->2->3->4->4->5->6
```

### 1ï¸âƒ£ æœ€å°å †

æ—¶é—´å¤æ‚åº¦åˆ†æï¼šå‡è®¾ $k$ ä¸ªé“¾è¡¨, å…± $n$ ä¸ªèŠ‚ç‚¹, æœ€å°å †å•æ¬¡æ“ä½œ $O(log k)$, åˆå§‹åŒ–å †éœ€è¦ $O(kÂ·logk)$, é‚£æ—¶é—´å¤æ‚åº¦ä¸º $O(kÂ·logk + nÂ·logk)$ï¼Œå³ $O(nÂ·logk)$ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](const ListNode* a, const ListNode* b) {
            return a->val > b->val;
        };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto& head : lists) {
            if (head) {
                pq.push(head);
            }
        }
        ListNode dummy{};
        ListNode* head = &dummy;
        while (!pq.empty()) {
            ListNode* node = pq.top();
            pq.pop();
            head->next = node;
            head = head->next;
            if (node->next)
                pq.push(node->next);
        }
        return dummy.next;
    }
};
```

### 2ï¸âƒ£ åˆ†æ²»æ³•

å‰ç½®é¢˜ç›®ï¼š[21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{};
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists, int l, int r) {
        if (l == r)
            return lists[l];
        if (l > r)
            return nullptr;
        int m = (l + r) >> 1;
        auto left = mergeKLists(lists, l, m);
        auto right = mergeKLists(lists, m + 1, r);
        return mergeTwoLists(left, right);
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return mergeKLists(lists, 0, lists.size() - 1);
    }
};
```

## å¤ä¹ ã€Œå †æ’åºã€

```cpp
class Solution {
public:
    // å‘ä¸‹è°ƒæ•´
    void heapify(vector<int>& nums, int i, int n) {
        int largest = i;
        int left = i * 2 + 1;
        int right = i * 2 + 2;
        if (left < n && nums[left] > nums[largest])
            largest = left;
        if (right < n && nums[right] > nums[largest])
            largest = right;
        if (largest != i) {
            swap(nums[largest], nums[i]);
            heapify(nums, largest, n);
        }
    }

    void heapsort(vector<int>& nums) {
        int n = nums.size();
        // i = n / 2 ä¹Ÿå¯, å¤šåˆ¤æ–­ä¸€æ¬¡è€Œå·²
        // å‘ä¸Šåˆå§‹åŒ–æ„å»º, è·å–æ•°ç»„æœ€å¤§å€¼
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(nums, i, n);
        }
        // æœ€å¤§å€¼ä¸æ–­è°ƒæ•´åˆ°æœ«å°¾, å¹¶å¯¹æ–°å…ƒç´  nums[0] å‘ä¸‹è¿›è¡Œè°ƒæ•´
        for (int i = n - 1; i >= 0; i--) {
            swap(nums[i], nums[0]);
            heapify(nums, 0, i);    // æ¯æ¬¡éƒ½ä» 0 å¼€å§‹è°ƒæ•´
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        heapsort(nums);
        return nums;
    }
};
```