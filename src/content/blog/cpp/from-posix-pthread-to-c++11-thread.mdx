---
title: ä» POSIX pthread åˆ° C++11 thread
description: ç½‘ç»œç¼–ç¨‹å®æˆ˜ä¸æºç åˆ†æ
publishDate: 2025-05-16
tags: [cpp]
language: Chinese
comment: true
draft: false
---

> æ¨èé˜…è¯»ï¼šhttps://chengxumiaodaren.com/docs/concurrent/

åœ¨ C++ å¼€å‘ä¸­ï¼ŒåŸç”Ÿçš„çº¿ç¨‹åº“ä¸»è¦æœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯ Linux ä¸‹çš„ `<pthread.h>`ï¼Œå¦ä¸€ä¸ªæ˜¯ C++11 æä¾›çš„ `<thread>`ã€‚

ä»¥å‰ä¸€ç›´ç”¨çš„æ˜¯ pthread çš„ API å†™ C++ çš„å¤šçº¿ç¨‹ç¨‹åºï¼Œç›´åˆ°å¬è¯´ä» C++11 å¼€å§‹çš„æ ‡å‡†åº“å·²ç»åŒ…å«äº†å¯¹çº¿ç¨‹çš„æ”¯æŒã€‚

## pthread

pthread ä¸­çš„ p æ˜¯ POSIX (Portable Operating System Interface) çš„ç¼©å†™ï¼Œæ˜¯ IEEE ä¸ºäº†åœ¨å„ç§ UNIX æ“ä½œç³»ç»Ÿä¸Šè¿è¡Œè½¯ä»¶ï¼Œè€Œå®šä¹‰ API çš„ä¸€ç³»åˆ—äº’ç›¸å…³è”çš„æ ‡å‡†æ€»ç§°ã€‚ç›¸æ¯”äº `std::thread` çš„ç®€ä¾¿æ˜“ç”¨ï¼Œ`pthread` åŠŸèƒ½æ¯”è¾ƒå¼ºå¤§ã€‚

### çº¿ç¨‹çš„åˆ›å»ºå’Œç®¡ç†

#### åˆ›å»ºçº¿ç¨‹ï½œ`pthread_create`

æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªåœ¨è¿›ç¨‹ä¸­å”¯ä¸€çš„çº¿ç¨‹æ ‡è¯†ç¬¦ï¼Œç”¨ä¸€ä¸ªæ•°æ®ç±»å‹ `pthread_t` è¡¨ç¤ºï¼Œè¯¥æ•°æ®ç±»å‹åœ¨ Linux ä¸­å°±æ˜¯ä¸€ä¸ªæ— ç¬¦å·é•¿æ•´å‹æ•°æ®ã€‚

```cpp
int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```

è‹¥åˆ›å»ºæˆåŠŸï¼Œè¿”å› 0ï¼›è‹¥å‡ºé”™ï¼Œåˆ™è¿”å›é”™è¯¯ç¼–å·ï¼š

- thread æ˜¯çº¿ç¨‹æ ‡è¯†ç¬¦ï¼Œä½†è¿™ä¸ªå‚æ•°ä¸æ˜¯ç”±ç”¨æˆ·æŒ‡å®šçš„ï¼Œè€Œæ˜¯ç”± `pthread_create` å‡½æ•°åœ¨åˆ›å»ºæ—¶å°†æ–°çº¿ç¨‹çš„æ ‡è¯†ç¬¦æ”¾åˆ°è¿™ä¸ªå˜é‡ä¸­
- attr æŒ‡å®šçº¿ç¨‹çš„å±æ€§ï¼Œå¯ä»¥ç”¨ NULL è¡¨ç¤ºé»˜è®¤å±æ€§
- start_routine æŒ‡å®šçº¿ç¨‹å¼€å§‹è¿è¡Œçš„å‡½æ•°
- arg æ˜¯ start_routine æ‰€éœ€çš„å‚æ•°ï¼Œæ˜¯ä¸€ä¸ªæ— ç±»å‹æŒ‡é’ˆ

é»˜è®¤åœ°ï¼Œçº¿ç¨‹åœ¨è¢«åˆ›å»ºæ—¶è¦è¢«èµ‹äºˆä¸€å®šçš„å±æ€§ï¼Œè¿™ä¸ªå±æ€§å­˜æ”¾åœ¨æ•°æ®ç±»å‹ `pthread_attr_t` ä¸­ï¼Œå®ƒåŒ…å«äº†çº¿ç¨‹çš„è°ƒåº¦ç­–ç•¥ï¼Œå †æ ˆçš„ç›¸å…³ä¿¡æ¯ï¼Œ`join` or `detach` çš„çŠ¶æ€ç­‰ã€‚

`pthread_attr_init` å’Œ `pthread_attr_destroy` å‡½æ•°åˆ†åˆ«ç”¨æ¥åˆ›å»ºå’Œé”€æ¯ `pthread_attr_t`ï¼Œå…·ä½“å‡½æ•°å£°æ˜å¯å‚è€ƒ man æ‰‹å†Œå¸®åŠ©ã€‚

#### ç»“æŸçº¿ç¨‹ï½œ`pthread_exit`ã€`pthread_cancel`

å½“å‘ç”Ÿä»¥ä¸‹æƒ…å½¢ä¹‹ä¸€æ—¶ï¼Œçº¿ç¨‹å°±ä¼šç»“æŸï¼š

- çº¿ç¨‹è¿è¡Œçš„å‡½æ•° return äº†ï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹çš„ä»»åŠ¡å·²ç»å®Œæˆï¼›
- çº¿ç¨‹è°ƒç”¨äº† `pthread_exit()`ï¼›
- å…¶ä»–çº¿ç¨‹è°ƒç”¨ `pthread_cancel()` ç»“æŸäº†çº¿ç¨‹ï¼›
- è¿›ç¨‹è°ƒç”¨ `exec()` æˆ– `exit()` ç»“æŸï¼›
- `main()` å‡½æ•°å…ˆç»“æŸäº†ï¼Œè€Œä¸” `main()` è‡ªå·±æ²¡æœ‰è°ƒç”¨ `pthread_exit()` æ¥ç­‰æ‰€æœ‰çº¿ç¨‹å®Œæˆä»»åŠ¡ã€‚

æ›´æŠ½è±¡åœ°è¯´ï¼Œçº¿ç¨‹ç»“æŸæ‰§è¡Œçš„æ–¹å¼å…±æœ‰ 3 ç§ï¼Œåˆ†åˆ«æ˜¯ï¼š

1. çº¿ç¨‹å°†æŒ‡å®šå‡½æ•°ä½“ä¸­çš„ä»£ç æ‰§è¡Œå®Œåè‡ªè¡Œç»“æŸï¼›
2. çº¿ç¨‹æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œé‡åˆ° `pthread_exit()` å‡½æ•°ç»“æŸæ‰§è¡Œã€‚
3. çº¿ç¨‹æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè¢«åŒä¸€è¿›ç¨‹ä¸­çš„å…¶å®ƒçº¿ç¨‹ï¼ˆåŒ…æ‹¬ä¸»çº¿ç¨‹ï¼‰å¼ºåˆ¶ç»ˆæ­¢ï¼›

å½“ç„¶ï¼Œä¸€ä¸ªçº¿ç¨‹ç»“æŸï¼Œå¹¶ä¸æ„å‘³ç€å®ƒçš„æ‰€æœ‰ä¿¡æ¯éƒ½å·²ç»æ¶ˆå¤±ï¼Œåé¢ä¼šçœ‹åˆ°**åƒµå°¸çº¿ç¨‹**çš„é—®é¢˜ã€‚

ä¸‹é¢ä»‹ç»ä¸¤ä¸ªå‡½æ•°ï¼š

```c
void pthread_exit(void *retval);
```

- `retval` æ˜¯ç”±ç”¨æˆ·æŒ‡å®šçš„å‚æ•°ï¼Œ`pthread_exit` å®Œæˆä¹‹åå¯ä»¥é€šè¿‡è¿™ä¸ªå‚æ•°è·å¾—çº¿ç¨‹çš„é€€å‡ºçŠ¶æ€/ä¿¡æ¯ã€‚

```c
int pthread_cancel(pthread_t thread);
```

- ä¸€ä¸ªçº¿ç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨ `pthread_cancel` å‡½æ•°æ¥è¯·æ±‚å–æ¶ˆåŒä¸€è¿›ç¨‹ä¸­çš„çº¿ç¨‹ï¼Œè¿™ä¸ªçº¿ç¨‹ç”± `thread` å‚æ•°æŒ‡å®šã€‚
- å¦‚æœæ“ä½œæˆåŠŸåˆ™è¿”å› 0ï¼Œå¤±è´¥åˆ™è¿”å›å¯¹åº”çš„é”™è¯¯ç¼–ç ã€‚

```cpp
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>  // sleep() å‡½æ•°

// çº¿ç¨‹æ‰§è¡Œçš„å‡½æ•°
void* thread_Fun(void* arg) {
    printf("æ–°å»ºçº¿ç¨‹å¼€å§‹æ‰§è¡Œ\n");
    sleep(10);
}

int main() {
    pthread_t myThread;
    void* mess;
    int value;
    int res;

    // åˆ›å»º myThread çº¿ç¨‹
    res = pthread_create(&myThread, NULL, thread_Fun, NULL);
    if (res != 0) {
        printf("çº¿ç¨‹åˆ›å»ºå¤±è´¥\n");
        return 0;
    }
    sleep(1);

    // å‘ myThread çº¿ç¨‹å‘é€ Cancel ä¿¡å·
    res = pthread_cancel(myThread);
    if (res != 0) {
        printf("ç»ˆæ­¢ myThread çº¿ç¨‹å¤±è´¥\n");
        return 0;
    }

    // è·å–å·²ç»ˆæ­¢çº¿ç¨‹çš„è¿”å›å€¼
    res = pthread_join(myThread, &mess);
    if (res != 0) {
        printf("ç­‰å¾…çº¿ç¨‹å¤±è´¥\n");
        return 0;
    }
    
    // å¦‚æœçº¿ç¨‹è¢«å¼ºåˆ¶ç»ˆæ­¢ï¼Œå…¶è¿”å›å€¼ä¸º PTHREAD_CANCELED
    if (mess == PTHREAD_CANCELED) {
        printf("myThread çº¿ç¨‹è¢«å¼ºåˆ¶ç»ˆæ­¢\n");
    } else {
        printf("error\n");
    }
    return 0;
}
```

```bash
$ ./pthread
æ–°å»ºçº¿ç¨‹å¼€å§‹æ‰§è¡Œ
myThread çº¿ç¨‹è¢«å¼ºåˆ¶ç»ˆæ­¢
```

#### ä¸€ä¸ªç®€å•çš„å¤šçº¿ç¨‹å®ç°

è¿™æ˜¯ä¸€ä¸ªéå¸¸ç®€å•çš„åŸºäº pthread çš„å¤šçº¿ç¨‹å®ç°ï¼š

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NUM_THREADS 5

void *printHello(void *thread_id) {
  long tid;
  tid = (long)thread_id;
  printf("Hello World! It's me, thread #%ld!\n", tid);
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  pthread_t threads[NUM_THREADS];
  int rc;
  long t;
  for (t = 0; t < NUM_THREADS; t++) {
    printf("In main: creating thread %ld\n", t);
    rc = pthread_create(&threads[t], NULL, printHello, (void *)t);
    if (rc) {
      printf("ERROR; return code frome pthread_create() is %d\n", rc);
      exit(-1);
    }
  }
  // Last thing that main() should do
  pthread_exit(NULL);
}
```

```bash
gcc -Wall _pthread.c -lpthread -o pthread
./pthread
```

```bash
In main: creating thread 0
In main: creating thread 1
Hello World! It's me, thread #0!
In main: creating thread 2
Hello World! It's me, thread #1!
In main: creating thread 3
Hello World! It's me, thread #2!
In main: creating thread 4
Hello World! It's me, thread #3!
Hello World! It's me, thread #4!
```

æ³¨æ„è¾“å‡ºçš„é¡ºåºå¯èƒ½ä¸åŒï¼Œ è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ï¼Œ`main()` æ˜¾ç¤ºåœ°è°ƒç”¨äº† `pthread_exit()` æ¥ç­‰å¾…å…¶ä»–çº¿ç¨‹çš„ç»“æŸï¼ˆå¦‚æœä¸ä½¿ç”¨è¿™ä¸ªå‡½æ•°çš„è¯ï¼Œå¯èƒ½ `main()` å‡½æ•°ç»“æŸäº†ä¹Ÿæœ‰çº¿ç¨‹æ²¡æœ‰æ‰§è¡Œå®Œæ¯•ï¼‰

#### ç»™çº¿ç¨‹ä¼ å…¥åˆå§‹åŒ–å‚æ•°

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NUM_THREADS 8

char *messages[NUM_THREADS];

struct thread_data {
  int tid;
  int sum;
  char *msg;
};

struct thread_data _datas[NUM_THREADS];

void *printHello(void *thread_arg) {
  int task_id, sum;
  char *hello_msg;
  struct thread_data *my_data;
  
  my_data = (struct thread_data *)thread_arg;
  task_id = my_data->tid;
  sum = my_data->sum;
  hello_msg = my_data->msg;
  
  // sleep(1);
  printf("Thread %d: %s Sum = %d\n", task_id, hello_msg, sum);
  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  pthread_t threads[NUM_THREADS];
  int *task_ids[NUM_THREADS];
  int rc, t, sum;

  sum = 0;
  messages[0] = "English: Hello World!";
  messages[1] = "French: Bonjour, le monde!";
  messages[2] = "Spanish: Hola al mundo";
  messages[3] = "Klingon: Nuq neH!";
  messages[4] = "German: Guten Tag, Welt!";
  messages[5] = "Russian: Zdravstvytye, mir!";
  messages[6] = "Japan: Sekai e konnichiwa!";
  messages[7] = "Latin: Orbis, te saluto!";

  for (t = 0; t < NUM_THREADS; t++) {
    sum = sum + t;
    _datas[t].tid = t;
    _datas[t].sum = sum;
    _datas[t].msg = messages[t];
    printf("Creating thread %d\n", t);
    rc = pthread_create(&threads[t], NULL, printHello, (void *)&_datas[t]);
    if (rc) {
      printf("ERROR; return code from pthread_create() is %d\n", rc);
      exit(-1);
    }
  }
  pthread_exit(NULL);
}
```

```bash
Creating thread 0
Creating thread 1
Thread 0: English: Hello World! Sum = 0
Creating thread 2
Thread 1: French: Bonjour, le monde! Sum = 1
Creating thread 3
Thread 2: Spanish: Hola al mundo Sum = 3
Creating thread 4
Thread 3: Klingon: Nuq neH! Sum = 6
Creating thread 5
Thread 4: German: Guten Tag, Welt! Sum = 10
Creating thread 6
Thread 5: Russian: Zdravstvytye, mir! Sum = 15
Creating thread 7
Thread 6: Japan: Sekai e konnichiwa! Sum = 21
Thread 7: Latin: Orbis, te saluto! Sum = 28
```

#### å¯¹çº¿ç¨‹çš„é˜»å¡ï½œ`pthread_join`ã€`pthread_detach`

é˜»å¡æ—¶çº¿ç¨‹ä¹‹é—´ã€Œ**åŒæ­¥**ã€çš„ä¸€ç§æ–¹æ³•ã€‚

```c
int pthread_join(pthread_t thread_id, void **value_ptr);
```

- `pthread_join` å‡½æ•°ä¼šè®©è°ƒç”¨å®ƒçš„çº¿ç¨‹ç­‰å¾… `thread_id` çº¿ç¨‹è¿è¡Œç»“æŸä¹‹åå†è¿è¡Œï¼ˆå¦‚æœæ˜¯ `main()` è°ƒç”¨ï¼Œåˆ™é˜»å¡ main çº¿ç¨‹ï¼Œç›´åˆ° join çš„æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œç»“æŸ â€”â€” å¸¸ç”¨äºç­‰å¾… main ä¸­åˆ›å»ºçš„æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼‰
- `value_ptr` å­˜æ”¾äº†å…¶ä»–çº¿ç¨‹çš„è¿”å›å€¼

ä¸€ä¸ªå¯ä»¥è¢« join çš„çº¿ç¨‹ï¼Œä»…ä»…å¯ä»¥è¢«å¦ä¸€ä¸ªçº¿ç¨‹ joinï¼Œå¦‚æœåŒæ—¶æœ‰å¤šä¸ªçº¿ç¨‹å°è¯• join åŒä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œæœ€ç»ˆç»“æœæ˜¯æœªçŸ¥çš„ï¼›å¦å¤–ï¼Œçº¿ç¨‹ä¸èƒ½ join è‡ªå·±ã€‚ä¸Šé¢æåˆ°è¿‡ï¼Œåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œè¦èµ‹äºˆå®ƒä¸€å®šçš„å±æ€§ï¼Œè¿™å…¶ä¸­å°±åŒ…æ‹¬ joinable or detachable çš„å±æ€§ï¼Œåªæœ‰è¢«å£°æ˜ç§° joinable çš„çº¿ç¨‹æ‰å¯ä»¥è¢«å…¶ä»–çº¿ç¨‹ joinã€‚

POSIX æ ‡å‡†çš„æœ€ç»ˆç‰ˆæœ¬æŒ‡å‡ºçº¿ç¨‹åº”è¯¥è¢«è®¾ç½®æˆ joinable çš„ï¼Œæ˜¾å¼è®¾ç½®ä¸€ä¸ªçº¿ç¨‹ä¸º joinableï¼Œéœ€è¦ä»¥ä¸‹å››ä¸ªæ­¥éª¤ï¼š

- Declare a pthread attribute variable of the `pthread_attr_t` data type
- Initialize the attribute variable with `pthread_attr_init()`
- Set the attribute detached status with `pthread_attr_setdetchstate()`
- When done, free library resources used by the attribute with `pthread_attr_destroy()`

`pthread_join()` å‡½æ•°ä¼šä¸€ç›´é˜»å¡è°ƒç”¨å®ƒçš„çº¿ç¨‹ï¼Œç›´è‡³ç›®æ ‡çº¿ç¨‹æ‰§è¡Œç»“æŸï¼ˆæ¥æ”¶åˆ°ç›®æ ‡çº¿ç¨‹çš„è¿”å›å€¼ï¼‰ï¼Œé˜»å¡çŠ¶æ€æ‰ä¼šè§£é™¤ã€‚å¦‚æœ pthread_join() å‡½æ•°æˆåŠŸç­‰åˆ°äº†ç›®æ ‡çº¿ç¨‹æ‰§è¡Œç»“æŸï¼ˆæˆåŠŸè·å–åˆ°ç›®æ ‡çº¿ç¨‹çš„è¿”å›å€¼ï¼‰ï¼Œè¿”å›å€¼ä¸ºæ•°å­— 0ï¼›åä¹‹å¦‚æœæ‰§è¡Œå¤±è´¥ï¼Œå‡½æ•°ä¼šæ ¹æ®å¤±è´¥åŸå› è¿”å›ç›¸åº”çš„éé›¶å€¼ï¼Œæ¯ä¸ªéé›¶å€¼éƒ½å¯¹åº”ç€ä¸åŒçš„å®ï¼Œä¾‹å¦‚ï¼š

- `EDEADLK`ï¼šæ£€æµ‹åˆ°çº¿ç¨‹å‘ç”Ÿäº†æ­»é”ã€‚
- `EINVAL`ï¼šåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œè¦ä¹ˆç›®æ ‡çº¿ç¨‹æœ¬èº«ä¸å…è®¸å…¶å®ƒçº¿ç¨‹è·å–å®ƒçš„è¿”å›å€¼ï¼Œè¦ä¹ˆäº‹å…ˆå°±å·²ç»æœ‰çº¿ç¨‹è°ƒç”¨ `pthread_join()` å‡½æ•°è·å–åˆ°äº†ç›®æ ‡çº¿ç¨‹çš„è¿”å›å€¼ã€‚
- `ESRCH`ï¼šæ‰¾ä¸åˆ°æŒ‡å®šçš„ thread çº¿ç¨‹ã€‚

å†æ¬¡å¼ºè°ƒï¼Œä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç»“æŸçš„è¿”å›å€¼åªèƒ½ç”±ä¸€ä¸ª `pthread_join()` å‡½æ•°è·å–ï¼Œå½“æœ‰å¤šä¸ªçº¿ç¨‹è°ƒç”¨ `pthread_join()` å‡½æ•°è·å–åŒä¸€ä¸ªçº¿ç¨‹çš„æ‰§è¡Œç»“æœæ—¶ï¼Œå“ªä¸ªçº¿ç¨‹æœ€å…ˆæ‰§è¡Œ `pthread_join()` å‡½æ•°ï¼Œæ‰§è¡Œç»“æœå°±ç”±é‚£ä¸ªçº¿ç¨‹è·å¾—ï¼Œå…¶å®ƒçº¿ç¨‹çš„ `pthread_join()` å‡½æ•°éƒ½å°†æ‰§è¡Œå¤±è´¥ã€‚

å¯¹äºä¸€ä¸ªé»˜è®¤å±æ€§çš„çº¿ç¨‹ A æ¥è¯´ï¼Œçº¿ç¨‹å ç”¨çš„èµ„æºå¹¶ä¸ä¼šå› ä¸ºæ‰§è¡Œç»“æŸè€Œå¾—åˆ°é‡Šæ”¾ã€‚è€Œé€šè¿‡åœ¨å…¶å®ƒçº¿ç¨‹ä¸­æ‰§è¡Œ`pthread_join(A,NULL);`è¯­å¥ï¼Œå¯ä»¥è½»æ¾å®ç°â€œåŠæ—¶é‡Šæ”¾çº¿ç¨‹ A æ‰€å èµ„æºâ€çš„ç›®çš„ã€‚ 

```c
#include <errno.h>  //ä½¿ç”¨å® ESRCH
#include <pthread.h>
#include <stdio.h>

// çº¿ç¨‹æ‰§è¡Œçš„å‡½æ•°
void *ThreadFun(void *arg) { pthread_exit("test_msg"); }

int main() {
    int res;
    void *thread_result;
    pthread_t myThread;
    // åˆ›å»º myThread çº¿ç¨‹
    res = pthread_create(&myThread, NULL, ThreadFun, NULL);
    if (res != 0) {
        printf("çº¿ç¨‹åˆ›å»ºå¤±è´¥");
        return 0;
    }
    // é˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰å¾… myThread çº¿ç¨‹æ‰§è¡Œç»“æŸ
    res = pthread_join(myThread, &thread_result);
    if (res != 0) {
        printf("1ï¼šç­‰å¾…çº¿ç¨‹å¤±è´¥");
    }
    // è¾“å‡ºè·å–åˆ°çš„ myThread çº¿ç¨‹çš„è¿”å›å€¼
    printf("%s\n", (char *)thread_result);

    // å°è¯•å†æ¬¡è·å– myThread çº¿ç¨‹çš„è¿”å›å€¼
    res = pthread_join(myThread, &thread_result);
    if (res == ESRCH) {
        printf("2ï¼šç­‰å¾…çº¿ç¨‹å¤±è´¥ï¼Œçº¿ç¨‹ä¸å­˜åœ¨\n");
    }
    return 0;
}
```

```bash
$ ./pthread
test_msg
2ï¼šç­‰å¾…çº¿ç¨‹å¤±è´¥ï¼Œçº¿ç¨‹ä¸å­˜åœ¨
```

`__detachstate` å±æ€§å€¼ç”¨äºæŒ‡å®šçº¿ç¨‹ç»ˆæ­¢æ‰§è¡Œçš„æ—¶æœºï¼Œè¯¥å±æ€§çš„å€¼æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«æ˜¯ï¼š

- `PTHREAD_CREATE_JOINABLE`ï¼ˆé»˜è®¤å€¼ï¼‰ï¼šçº¿ç¨‹æ‰§è¡Œå®Œå‡½æ•°åä¸ä¼šè‡ªè¡Œé‡Šæ”¾èµ„æºï¼›
- `PTHREAD_CREATE_DETACHED`ï¼šçº¿ç¨‹æ‰§è¡Œå®Œå‡½æ•°åï¼Œä¼šè‡ªè¡Œç»ˆæ­¢å¹¶é‡Šæ”¾å ç”¨çš„èµ„æºã€‚

è¿˜æœ‰ `pthread_detach()` å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥å°†ç›®æ ‡çº¿ç¨‹çš„ `__detachstate` å±æ€§æ”¹ä¸º `PTHREAD_CREATE_DETACHED`ï¼Œè¯­æ³•æ ¼å¼å¦‚ä¸‹ï¼š

```c
int pthread_detach(pthread_t thread);
```

å…³äº `__detachstate` å±æ€§ï¼Œ`<pthread.h>` å¤´æ–‡ä»¶ä¸­æä¾›äº† 2 ä¸ªä¸å®ƒç›¸å…³çš„å‡½æ•°ï¼Œåˆ†åˆ«æ˜¯ï¼š

```c
int pthread_attr_getdetachstate(const pthread_attr_t * attr,int * detachstate);
int pthread_attr_setdetachstate(pthread_attr_t *sttrï¼Œint detachstate);
```

å¯ä»¥å¦‚ä¸‹åˆ›å»º detach çŠ¶æ€çš„çº¿ç¨‹ï¼š

```c
pthread_t tid;
pthread_attr_t attr;
pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
pthread_create(&tid, &attr, THREAD_FUNCTION, arg);
```

---

âš ï¸ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼š**åƒµå°¸çº¿ç¨‹ï¼ˆzombie threadï¼‰æ˜¯ä¸€ç§å·²ç»é€€å‡ºäº†çš„ joinable çº¿ç¨‹ï¼Œä½†æ˜¯ç­‰å¾…å…¶ä»–çº¿ç¨‹è°ƒç”¨ `pthread_join` æ¥ join å®ƒï¼Œä»¥æ”¶é›†å®ƒçš„é€€å‡ºä¿¡æ¯**ã€‚å¦‚æœæ²¡æœ‰å…¶ä»–çº¿ç¨‹è°ƒç”¨ `pthread_join` æ¥ join å®ƒçš„è¯ï¼Œå®ƒå ç”¨çš„ä¸€äº›ç³»ç»Ÿèµ„æºä¸ä¼šè¢«é‡Šæ”¾ï¼Œæ¯”å¦‚å †æ ˆã€‚å¦‚æœ `main()` å‡½æ•°éœ€è¦é•¿æ—¶é—´è¿è¡Œï¼Œå¹¶ä¸”åˆ›å»ºå¤§é‡ joinable çš„çº¿ç¨‹ï¼Œå°±æœ‰å¯èƒ½å‡ºç°å †æ ˆä¸è¶³çš„ errorã€‚

âš ï¸ **å¯¹äºé‚£äº›ä¸éœ€è¦ join çš„çº¿ç¨‹ï¼Œæœ€å¥½åˆ©ç”¨ `pthread_detach`ï¼Œè¿™æ ·å®ƒè¿è¡Œç»“æŸåï¼Œèµ„æºå°±ä¼šåŠæ—¶å¾—åˆ°é‡Šæ”¾**ã€‚æ³¨æ„ä¸€ä¸ªçº¿ç¨‹è¢«ä½¿ç”¨ `pthread_detach` ä¹‹åï¼Œå®ƒå°±ä¸èƒ½å†è¢«æ”¹æˆ joinable çš„äº†ã€‚

âš ï¸ æ€»è€Œè¨€ä¹‹ï¼Œåˆ›å»ºçš„æ¯ä¸€ä¸ªçº¿ç¨‹éƒ½åº”è¯¥ä½¿ç”¨ `pthread_join` æˆ–è€… `pthread_detach` å…¶ä¸­ä¸€ä¸ªï¼Œä»¥é˜²æ­¢åƒµå°¸çº¿ç¨‹çš„å‡ºç°ã€‚

#### Linux çº¿ç¨‹å±æ€§ä¹‹çº¿ç¨‹æ ˆå¤§å°ï½œ`pthread_attr_t`

çº¿ç¨‹çš„å±æ€§ç”¨ `pthread_attr_t` ç±»å‹çš„å˜é‡è¡¨ç¤ºï¼Œä½¿ç”¨æ­¤å˜é‡å‰ï¼Œå¿…é¡»è°ƒç”¨ `pthread_attr_init()` å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ï¼š

```c
int pthread_attr_init(pthread_attr_t * attr);
```

`pthread_attr_t` æ˜¯ä¸€ç§ç»“æ„ä½“ç±»å‹ï¼Œå†…éƒ¨åŒ…å«å¤šç§çº¿ç¨‹å±æ€§ï¼ˆæ›´å¤šå†…å®¹è¯·çœ‹å‚è€ƒèµ„æ–™ï¼‰ï¼š

```c
typedef struct
{
   int __detachstate;	// ç”¨äºæŒ‡å®šçº¿ç¨‹ç»ˆæ­¢æ‰§è¡Œçš„æ—¶æœº
   int __schedpolicy;	// æŒ‡å®šç³»ç»Ÿè°ƒåº¦è¯¥çº¿ç¨‹æ‰€ç”¨çš„ç®—æ³•
   struct sched_param __schedparam;		// è®¾ç½®çº¿ç¨‹çš„ä¼˜å…ˆçº§
   int __inheritsched;	// é»˜è®¤éµå¾ªçˆ¶çº¿ç¨‹çš„å±æ€§, ç”¨äºè‡ªå®šä¹‰çº¿ç¨‹çš„è°ƒåº¦å±æ€§
   int __scope;			// ç”¨äºæŒ‡å®šç›®æ ‡çº¿ç¨‹å’Œå“ªäº›çº¿ç¨‹æŠ¢å¤º CPU èµ„æº
   size_t __guardsize;	// ç”¨æ¥è®¾ç½®è­¦æˆ’ç¼“å†²åŒºçš„å¤§å°
   int __stackaddr_set;
   void* __stackaddr;
   size_t __stacksize;	// æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å±äºè‡ªå·±çš„å†…å­˜ç©ºé—´, çº¿ç¨‹æ‰§è¡Œå¦‚æœéœ€è¦è¾ƒå¤§çš„æ ˆå†…å­˜ï¼Œå°±éœ€è¦è‡ªå®šä¹‰çº¿ç¨‹æ‹¥æœ‰çš„æ ˆå¤§å°
} pthread_attr_t;
```

POSIX æ ‡å‡†æ²¡æœ‰è§„å®šä¸€ä¸ªçº¿ç¨‹çš„å †æ ˆå¤§å°ï¼Œå®‰å…¨å¯ç§»æ¤çš„ç¨‹åºä¸ä¼šä¾èµ–äºå…·ä½“å®ç°é»˜è®¤çš„å †æ ˆé™åˆ¶ï¼Œè€Œæ˜¯æ˜¾å¼åœ°è°ƒç”¨ `pthread_attr_setstacksize` æ¥åˆ†é…è¶³å¤Ÿçš„å †æ ˆç©ºé—´ã€‚

å…³äºå †æ ˆå¤§å°çš„ä¸€ä¸ªä¾‹å­ï¼š

```c
#include <pthread.h>

#define N_THREADS 5
#define N 1000
#define MEGEXTRA 1000000

pthread_attr_t _attr;

void* do_work(void* thread_id) {
    double A[N][N];
    int i, j;
    long tid;
    size_t my_stack_size;
    tid = (long)thread_id;
    pthread_attr_getstacksize(&_attr, &my_stack_size);
    printf("Thread %ld: stack size = %ld bytes \n", tid, my_stack_size);
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            A[i][j] = ((i * j) / 3.452) + (N - i);
        }
    }
    pthread_exit(NULL);
}

int main(int argc, char* argv[]) {
    pthread_t threads[N_THREADS];
    size_t stack_size;
    int rc;
    long t;

    pthread_attr_init(&_attr);
    pthread_attr_getstacksize(&_attr, &stack_size);
    printf("Default stack size = %li\n", stack_size);  // çº¿ç¨‹æ ˆå¤§å°: 8 MB

    stack_size = sizeof(double) * N * N + MEGEXTRA;
    printf("Amount of stack needed per thread = %li\n", stack_size);

    pthread_attr_setstacksize(&_attr, stack_size);
    printf("Creating threads with stack size = %li bytes\n", stack_size);

    for (t = 0; t < N_THREADS; t++) {
        rc = pthread_create(&threads[t], &_attr, do_work, (void*)t);
        if (rc) {
            printf("ERROR; return code from pthread_create() is %d\n", rc);
            exit(-1);
        }
    }
    printf("Creating %ld threads.\n", t);
    pthread_exit(NULL);
}
```

```bash
$ ./pthread 
Default stack size = 8388608
Amount of stack needed per thread = 9000000
Creating threads with stack size = 9000000 bytes
Creating 5 threads.
Thread 1: stack size = 9000000 bytes 
Thread 2: stack size = 9000000 bytes 
Thread 0: stack size = 9000000 bytes 
Thread 3: stack size = 9000000 bytes 
Thread 4: stack size = 9000000 bytes
```

å…¶ä»–ç›¸å…³å‡½æ•°ï¼š

```c
// è¿”å› thread ID
pthread_self();
// æ¯”è¾ƒä¸¤ä¸ªçº¿ç¨‹çš„ ID, å¦‚æœä¸åŒåˆ™è¿”å› 0, å¦åˆ™è¿”å›ä¸€ä¸ªéé›¶å€¼
pthread_equal(thread_1, thread_2);
```

### äº’æ–¥é” Mutex

Mutex å¸¸å¸¸è¢«ç”¨æ¥ä¿æŠ¤é‚£äº›å¯ä»¥è¢«å¤šä¸ªçº¿ç¨‹è®¿é—®çš„å…±äº«èµ„æºï¼Œæ¯”å¦‚å¯ä»¥é˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶æ›´æ–°åŒä¸€ä¸ªæ•°æ®æ—¶å‡ºç°æ··ä¹±ã€‚

ä½¿ç”¨äº’æ–¥é”çš„ä¸€èˆ¬æ­¥éª¤æ˜¯ï¼š

- åˆ›å»ºä¸€ä¸ªäº’æ–¥é”ï¼Œå³å£°æ˜ä¸€ä¸ª `pthread_mutex_t` ç±»å‹çš„æ•°æ®ï¼Œç„¶ååˆå§‹åŒ–ï¼Œåªæœ‰åˆå§‹åŒ–ä¹‹åæ‰èƒ½ä½¿ç”¨ï¼›
- å¤šä¸ªçº¿ç¨‹å°è¯•é”å®šè¿™ä¸ªäº’æ–¥é”ï¼›
- åªæœ‰ä¸€ä¸ªæˆåŠŸé”å®šäº’æ–¥é”ï¼Œæˆä¸ºäº’æ–¥é”çš„æ‹¥æœ‰è€…ï¼Œç„¶åè¿›è¡Œä¸€äº›æŒ‡ä»¤ï¼›
- æ‹¥æœ‰è€…è§£é”äº’æ–¥é”ï¼›
- å…¶ä»–çº¿ç¨‹å°è¯•é”å®šè¿™ä¸ªäº’æ–¥é”ï¼Œé‡å¤ä¸Šé¢çš„è¿‡ç¨‹ï¼›
- æœ€åäº’æ–¥é”è¢«æ˜¾å¼åœ°è°ƒç”¨ `pthread_mutex_destroy` æ¥è¿›è¡Œé”€æ¯ã€‚

æœ‰ä¸¤ç§æ–¹å¼åˆå§‹åŒ–ä¸€ä¸ªäº’æ–¥é”ï¼š

1ï¸âƒ£ ç¬¬ä¸€ç§ï¼Œåˆ©ç”¨å·²ç»å®šä¹‰çš„å¸¸é‡åˆå§‹åŒ–ï¼Œä¾‹å¦‚ï¼š

```c
pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
```

2ï¸âƒ£ ç¬¬äºŒç§æ–¹å¼æ˜¯è°ƒç”¨  `pthread_mutex_init(mutex, attr)` è¿›è¡Œåˆå§‹åŒ–ã€‚

å½“å¤šä¸ªçº¿ç¨‹åŒæ—¶å»é”å®šåŒä¸€ä¸ªäº’æ–¥é”æ—¶ï¼Œå¤±è´¥çš„é‚£äº›çº¿ç¨‹

- å¦‚æœæ˜¯ç”¨ `pthread_mutex_lock` å‡½æ•°ï¼Œé‚£ä¹ˆä¼šè¢«é˜»å¡ï¼Œç›´åˆ°è¿™ä¸ªäº’æ–¥é”è¢«è§£é”ï¼Œå®ƒä»¬å†ç»§ç»­ç«äº‰ï¼›
- å¦‚æœæ˜¯ç”¨ `pthread_mutex_trylock` å‡½æ•°ï¼Œé‚£ä¹ˆå¤±è´¥è€…åªä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚

æœ€åéœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼Œä¿æŠ¤å…±äº«æ•°æ®æ˜¯ç¨‹åºå‘˜çš„è´£ä»»ã€‚ç¨‹åºå‘˜è¦è´Ÿè´£æ‰€æœ‰å¯ä»¥è®¿é—®è¯¥æ•°æ®çš„çº¿ç¨‹éƒ½ä½¿ç”¨ `mutex` è¿™ç§æœºåˆ¶ï¼Œå¦åˆ™ï¼Œä¸ä½¿ç”¨ `mutex` çš„çº¿ç¨‹è¿˜æ˜¯æœ‰å¯èƒ½å¯¹æ•°æ®é€ æˆç ´åã€‚

ç›¸å…³å‡½æ•°ï¼š

```c
int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr);
int pthread_mutex_destroy(pthread_mutex_t *__mutex);
int pthread_mutex_lock(pthread_mutex_t *__mutex);
int pthread_mutex_unlock(pthread_mutex_t *__mutex);
int pthread_mutex_trylock(pthread_mutex_t *__mutex);
int pthread_mutexattr_init(pthread_mutexattr_t *__attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr);
```

#### Example

ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ©ç”¨å¤šçº¿ç¨‹è¿›è¡Œå‘é‡ç‚¹ä¹˜çš„ç¨‹åºï¼Œå…¶ä¸­éœ€è¦å¯¹ `dotstr.sum` è¿™ä¸ªå…±åŒè¯»å†™çš„æ•°æ®è¿›è¡Œä¿æŠ¤ã€‚

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

/*
The following structure contains the necessary information
to allow the function "dotprod" to access its input data and
place its output into the structure.  This structure is
unchanged from the sequential version.
*/

typedef struct {
    double *a;
    double *b;
    double sum;
    int veclen;
} DOTDATA;

/* Define globally accessible variables and a mutex */

#define NUMTHRDS 4
#define VECLEN 100000
DOTDATA dotstr;
pthread_t callThd[NUMTHRDS];
pthread_mutex_t mutexsum;

/*
The function dotprod is activated when the thread is created.
As before, all input to this routine is obtained from a structure
of type DOTDATA and all output from this function is written into
this structure. The benefit of this approach is apparent for the
multi-threaded program: when a thread is created we pass a single
argument to the activated function - typically this argument
is a thread number. All  the other information required by the
function is accessed from the globally accessible structure.
*/

void *dotprod(void *arg) {
    /* Define and use local variables for convenience */

    int i, start, end, len;
    long offset;
    double mysum, *x, *y;
    offset = (long)arg;

    len = dotstr.veclen;
    start = offset * len;
    end = start + len;
    x = dotstr.a;
    y = dotstr.b;

    /*
    Perform the dot product and assign result
    to the appropriate variable in the structure.
    */
    mysum = 0;
    for (i = start; i < end; i++) {
        mysum += (x[i] * y[i]);
    }

    /*
    Lock a mutex prior to updating the value in the shared
    structure, and unlock it upon updating.
    */
    pthread_mutex_lock(&mutexsum);
    dotstr.sum += mysum;
    printf("Thread %ld did %d to %d: mysum=%f global sum=%f\n", offset, start, end, mysum, dotstr.sum);
    pthread_mutex_unlock(&mutexsum);
    pthread_exit((void *)0);
}

/*
The main program creates threads which do all the work and then print out result
upon completion. Before creating the threads, The input data is created. Since
all threads update a shared structure, we need a mutex for mutual exclusion.
The main thread needs to wait for all threads to complete, it waits for each one
of the threads. We specify a thread attribute value that allow the main thread to
join with the threads it creates. Note also that we free up handles  when they
are no longer needed.
*/

int main(int argc, char *argv[]) {
    long i;
    double *a, *b;
    void *status;
    pthread_attr_t attr;

    /* Assign storage and initialize values */

    a = (double *)malloc(NUMTHRDS * VECLEN * sizeof(double));
    b = (double *)malloc(NUMTHRDS * VECLEN * sizeof(double));

    for (i = 0; i < VECLEN * NUMTHRDS; i++) {
        a[i] = 1;
        b[i] = a[i];
    }

    dotstr.veclen = VECLEN;
    dotstr.a = a;
    dotstr.b = b;
    dotstr.sum = 0;

    pthread_mutex_init(&mutexsum, NULL);

    /* Create threads to perform the dotproduct  */
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    for (i = 0; i < NUMTHRDS; i++) {
        /* Each thread works on a different set of data.
         * The offset is specified by 'i'. The size of
         * the data for each thread is indicated by VECLEN.
         */
        pthread_create(&callThd[i], &attr, dotprod, (void *)i);
    }

    pthread_attr_destroy(&attr);

    /* Wait on the other threads */
    for (i = 0; i < NUMTHRDS; i++) {
        pthread_join(callThd[i], &status);
    }
    /* After joining, print out the results and cleanup */

    printf("Sum = %f \n", dotstr.sum);
    free(a);
    free(b);
    pthread_mutex_destroy(&mutexsum);
    pthread_exit(NULL);
}
```

```bash
$ ./pthread 
Thread 0 did 0 to 100000: mysum=100000.000000 global sum=100000.000000
Thread 2 did 200000 to 300000: mysum=100000.000000 global sum=200000.000000
Thread 1 did 100000 to 200000: mysum=100000.000000 global sum=300000.000000
Thread 3 did 300000 to 400000: mysum=100000.000000 global sum=400000.000000
Sum = 400000.000000
```

### æ¡ä»¶å˜é‡ Condition Variable

äº’æ–¥é”åªæœ‰ä¸¤ç§çŠ¶æ€ï¼Œè¿™é™åˆ¶äº†å®ƒçš„ç”¨é€”ã€‚æ¡ä»¶å˜é‡å…è®¸çº¿ç¨‹åœ¨é˜»å¡çš„æ—¶å€™ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹å‘é€çš„ä¿¡å·ï¼Œå½“æ”¶åˆ°ä¿¡å·åï¼Œé˜»å¡çš„çº¿ç¨‹å°±è¢«å”¤é†’å¹¶è¯•å›¾é”å®šä¸ä¹‹ç›¸å…³çš„äº’æ–¥é”ã€‚**æ¡ä»¶å˜é‡è¦å’Œäº’æ–¥é”ç»“åˆä½¿ç”¨**ã€‚

#### æ¡ä»¶å˜é‡çš„å£°æ˜å’Œåˆå§‹åŒ–

é€šè¿‡å£°æ˜ `pthread_cond_t` ç±»å‹çš„æ•°æ®ï¼Œå¹¶ä¸”å¿…é¡»å…ˆåˆå§‹åŒ–æ‰èƒ½ä½¿ç”¨ã€‚

åˆå§‹åŒ–çš„æ–¹æ³•ä¹Ÿæœ‰ä¸¤ç§ï¼š

1ï¸âƒ£ ç¬¬ä¸€ç§ï¼Œåˆ©ç”¨å†…éƒ¨å®šä¹‰çš„å¸¸é‡ï¼Œä¾‹å¦‚ï¼š

```c
pthread_cond_t myconvar = PTHREAD_COND_INITIALIZER;
```

2ï¸âƒ£ ç¬¬äºŒç§ï¼Œåˆ©ç”¨å‡½æ•° `pthread_cond_init(cond, attr)`ï¼Œå…¶ä¸­ attr ç”± `pthread_condattr_init()` å’Œ `pthread_condattr_destroy()` åˆ›å»ºå’Œé”€æ¯ï¼›å¯ä»¥ç”¨ `pthread_cond_destroy()` é”€æ¯ä¸€ä¸ªæ¡ä»¶å˜é‡ã€‚

ç›¸å…³å‡½æ•°ï¼š

```c
int pthread_cond_wait(pthread_cond_t *__restrict__ __cond, pthread_mutex_t *__restrict__ __mutex);
int pthread_cond_signal(pthread_cond_t *__cond);
int pthread_cond_broadcast(pthread_cond_t *__cond);
```

- `pthread_cond_wait()` ä¼šé˜»å¡è°ƒç”¨å®ƒçš„çº¿ç¨‹ï¼Œç›´åˆ°æ”¶åˆ°æŸä¸€ä¸ªä¿¡å·ï¼šè¿™ä¸ªå‡½æ•°éœ€è¦åœ¨ mutex å·²ç»è¢«é”ä¹‹åè¿›è¡Œè°ƒç”¨ï¼Œå¹¶ä¸”å½“çº¿ç¨‹è¢«é˜»å¡æ—¶ï¼Œä¼šè‡ªåŠ¨è§£é” mutexã€‚ä¿¡å·æ”¶åˆ°åï¼Œçº¿ç¨‹è¢«å”¤é†’ï¼Œè¿™æ—¶ mutex åˆä¼šè¢«è¿™ä¸ªçº¿ç¨‹é”å®šã€‚
- `pthread_cond_signal()` å‡½æ•°ç»“æŸæ—¶ï¼Œå¿…é¡»è§£é” mutexï¼Œä»¥ä¾› `pthread_cond_wait()` é”å®šmutexã€‚
- **å½“ä¸æ­¢ä¸€ä¸ªçº¿ç¨‹åœ¨ç­‰å¾…ä¿¡å·æ—¶**ï¼Œè¦ç”¨ `pthread_cond_broadcast()` ä»£æ›¿ `pthread_cond_signal()` æ¥å‘Šè¯‰æ‰€æœ‰è¢«è¯¥æ¡ä»¶å˜é‡é˜»å¡çš„çº¿ç¨‹ç»“æŸé˜»å¡çŠ¶æ€ã€‚

#### Example

ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œä¸‰ä¸ªçº¿ç¨‹å…±åŒè®¿é—® `count` å˜é‡ï¼Œthread 2 å’Œ thread 3 ç«äº‰åœ°å¯¹å…¶è¿›è¡ŒåŠ  1 çš„æ“ä½œï¼Œthread 1 ç­‰ count è¾¾åˆ° 12 çš„æ—¶å€™ï¼Œä¸€æ¬¡æ€§åŠ  125 ã€‚ ç„¶å thread 2 å’Œ thread 3 å†å»ç«äº‰ count çš„æ§åˆ¶æƒï¼Œç›´åˆ°å®Œæˆè‡ªå·±çš„å¯¹ count åŠ  10 æ¬¡çš„ä»»åŠ¡ã€‚

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NUM_THREADS 3
#define TCOUNT 10
#define COUNT_LIMIT 12

int count = 0;
pthread_mutex_t count_mutex;
pthread_cond_t count_threshold_cv;

void *inc_count(void *t) {
    int i;
    long my_id = (long)t;

    for (i = 0; i < TCOUNT; i++) {
        pthread_mutex_lock(&count_mutex);
        count++;

        /*
        Check the value of count and signal waiting thread when condition is
        reached.  Note that this occurs while mutex is locked.
        */
        if (count == COUNT_LIMIT) {
            printf("inc_count(): thread %ld, count = %d  Threshold reached. ", my_id, count);
            pthread_cond_signal(&count_threshold_cv);
            printf("Just sent signal.\n");
        }
        printf("inc_count(): thread %ld, count = %d, unlocking mutex\n", my_id, count);
        pthread_mutex_unlock(&count_mutex);

        /* Do some work so threads can alternate on mutex lock */
        sleep(1);
    }
    pthread_exit(NULL);
}

void *watch_count(void *t) {
    long my_id = (long)t;

    printf("Starting watch_count(): thread %ld\n", my_id);

    /*
    Lock mutex and wait for signal.  Note that the pthread_cond_wait routine
    will automatically and atomically unlock mutex while it waits.
    Also, note that if COUNT_LIMIT is reached before this routine is run by
    the waiting thread, the loop will be skipped to prevent pthread_cond_wait
    from never returning.
    */
    pthread_mutex_lock(&count_mutex);
    while (count < COUNT_LIMIT) {
        printf("watch_count(): thread %ld Count= %d. Going into wait...\n", my_id, count);
        pthread_cond_wait(&count_threshold_cv, &count_mutex);
        printf("watch_count(): thread %ld Condition signal received. Count= %d\n", my_id, count);
        printf("watch_count(): thread %ld Updating the value of count...\n", my_id, count);
        count += 125;
        printf("watch_count(): thread %ld count now = %d.\n", my_id, count);
    }
    printf("watch_count(): thread %ld Unlocking mutex.\n", my_id);
    pthread_mutex_unlock(&count_mutex);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    int i, rc;
    long t1 = 1, t2 = 2, t3 = 3;
    pthread_t threads[3];
    pthread_attr_t attr;

    /* Initialize mutex and condition variable objects */
    pthread_mutex_init(&count_mutex, NULL);
    pthread_cond_init(&count_threshold_cv, NULL);

    /* For portability, explicitly create threads in a joinable state */
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    pthread_create(&threads[0], &attr, watch_count, (void *)t1);
    pthread_create(&threads[1], &attr, inc_count, (void *)t2);
    pthread_create(&threads[2], &attr, inc_count, (void *)t3);

    /* Wait for all threads to complete */
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    printf("Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n", NUM_THREADS, count);

    /* Clean up and exit */
    pthread_attr_destroy(&attr);
    pthread_mutex_destroy(&count_mutex);
    pthread_cond_destroy(&count_threshold_cv);
    pthread_exit(NULL);
}
```

```bash
$ ./pthread 
Starting watch_count(): thread 1
inc_count(): thread 2, count = 1, unlocking mutex
inc_count(): thread 3, count = 2, unlocking mutex
watch_count(): thread 1 Count= 2. Going into wait...
inc_count(): thread 2, count = 3, unlocking mutex
inc_count(): thread 3, count = 4, unlocking mutex
inc_count(): thread 2, count = 5, unlocking mutex
inc_count(): thread 3, count = 6, unlocking mutex
inc_count(): thread 2, count = 7, unlocking mutex
inc_count(): thread 3, count = 8, unlocking mutex
inc_count(): thread 2, count = 9, unlocking mutex
inc_count(): thread 3, count = 10, unlocking mutex
inc_count(): thread 2, count = 11, unlocking mutex
inc_count(): thread 3, count = 12  Threshold reached. Just sent signal.
inc_count(): thread 3, count = 12, unlocking mutex
watch_count(): thread 1 Condition signal received. Count= 12
watch_count(): thread 1 Updating the value of count...
watch_count(): thread 1 count now = 137.
watch_count(): thread 1 Unlocking mutex.
inc_count(): thread 2, count = 138, unlocking mutex
inc_count(): thread 3, count = 139, unlocking mutex
inc_count(): thread 2, count = 140, unlocking mutex
inc_count(): thread 3, count = 141, unlocking mutex
inc_count(): thread 2, count = 142, unlocking mutex
inc_count(): thread 3, count = 143, unlocking mutex
inc_count(): thread 3, count = 144, unlocking mutex
inc_count(): thread 2, count = 145, unlocking mutex
Main(): Waited and joined with 3 threads. Final value of count = 145. Done.
```

## std::thread

åœ¨ C++11 ä¸­å¼•å…¥çš„çº¿ç¨‹åº“ `std::thread` å®é™…æ˜¯åŸºäº `pthread` å®ç°çš„ï¼Œåç»­ä¸»è¦ä»‹ç»ï¼š

- å¦‚ä½•ä½¿ç”¨ `std::thread` åˆ›å»ºçº¿ç¨‹
- æ·±å…¥å‰–æ `std::thread` çš„è®¾è®¡åŸç†

### ä½¿ç”¨ std::thread

å½“ä½ åˆ›å»ºäº†ä¸€ä¸ªï¼ˆéç©ºçš„ï¼‰çº¿ç¨‹å¯¹è±¡æ—¶ï¼Œå¯¹åº”çº¿ç¨‹å°±ä¼šæ‰§è¡Œï¼Œä¸éœ€è¦æ˜¾å¼çš„è°ƒç”¨ `start` æˆ–è€… `run`ï¼ˆpthread ä¹Ÿæ˜¯ï¼‰ã€‚å¦‚æœä¹‹å‰ä½ æ²¡æœ‰ç”¨è¿‡ pthreadï¼Œä¹Ÿè®¸ä¸ä¼šç†è§£ä½•ä¸ºâ€œæ–¹ä¾¿å¾—å‡ºäººæ„æ–™â€ï¼š

- `pthread_create` åªæ¥å— `void *f(void *)`ï¼Œæ‰€ä»¥å¦‚æœä½ æƒ³è°ƒç”¨ç°æˆçš„å‡½æ•°ï¼Œè¿˜éœ€è¦åŒ…è£…ä¸€ä¸‹ï¼›
- è€Œä¸” `pthread_create` å…¶å‡½æ•°æ¥å—å‚æ•°ï¼ˆç¬¬å››ä¸ªå‚æ•°ï¼‰ç±»å‹ä¸º `void *arg`ï¼Œå¦‚æœè¦ä¼ å¤šä¸ªå‚æ•°ï¼Œè¿˜éœ€è¦å®šä¹‰ç»“æ„ä½“ï¼Œæ¥ç€å°†ç»“æ„ä½“è½¬ä¸º `void *` ç±»å‹å†ä¼ é€’è¿›å»ï¼›
- è¿™è¿˜æ²¡å®Œï¼Œä¼ é€’è¿›å»çš„å‚æ•°è¿˜éœ€è¦åœ¨å…¶å†…éƒ¨å‡½æ•°ä¸­ï¼Œé‡æ–°è½¬å‹æˆï¼ˆå¯èƒ½æ˜¯ä¸€æ¬¡æ€§çš„ï¼‰æŸä¸ªç»“æ„ä½“ï¼Œæœ€åæ‰èƒ½å–å‡ºå…¶ä¸­çš„å˜é‡ï¼›

åˆ›å»ºçº¿ç¨‹åï¼Œè°ƒç”¨ `Thread.join` å°±ä¼šé˜»å¡åˆ°çº¿ç¨‹æ‰§è¡Œç»“æŸä¸ºæ­¢ï¼ˆç›¸å½“äº`pthread_join`ï¼‰ã€‚ä½ ä¹Ÿå¯ä»¥é€‰æ‹© `detach` è¯¥çº¿ç¨‹ï¼Œè¿™æ—¶å€™çº¿ç¨‹ä¼šç‹¬ç«‹æ‰§è¡Œï¼Œä¸ä¼šéšè°ƒç”¨è€…ç»ˆæ­¢è€Œç»“æŸã€‚

åœ¨å¦‚ä¸‹çš„ demo ä¸­ï¼Œä¸»çº¿ç¨‹ä¸­ä½¿ç”¨ `std::thread` åˆ›å»º 3 ä¸ªå­çº¿ç¨‹ï¼Œçº¿ç¨‹å…¥å£å‡½æ•°æ˜¯ `do_some_work`ï¼Œåœ¨ä¸»çº¿ç¨‹è¿è¡Œç»“æŸå‰ç­‰å¾…å­çº¿ç¨‹çš„ç»“æŸã€‚

> æ³¨ï¼šåœ¨æ„é€ çº¿ç¨‹å¯¹è±¡ `std::thread{do_some_work, i}` çš„æ—¶å€™ï¼Œè¿˜æ˜¯å»ºè®®ä½¿ç”¨ `{}` è€Œä¸æ˜¯ `()`ï¼Œä»¥é˜²æ­¢ç¼–è¯‘å™¨äº§ç”Ÿé”™è¯¯çš„å†³è®®ï¼Œå…·ä½“åŸå› å¯ä»¥å‚è€ƒæ–‡ç« ï¼ˆ[æ·±å…¥äº†è§£ C++ï¼šåˆ«å†å¾˜å¾Šäº {} ä¸ () ä¹‹é—´äº†](https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247484397&idx=1&sn=02bdcfae05bf50963509187e0131ba6d&chksm=c1f68ddcf68104ca42c6d11ace316b1e146b76e1473b1f17d25d7211635fe983735cf72834f8&token=327902945&lang=zh_CN#rd)ï¼‰

```cpp
// #include <bits/stdc++.h>
#include <iostream>
#include <thread>
#include <vector>

const int N_THREADS = 3;

void do_some_work(int num) { std::cout << "thread: " << num << std::endl; }

int main(int argc, char const* argv[]) {
    std::vector<std::thread> thread_list;
    thread_list.reserve(N_THREADS);

    // start thread
    for (int i = 0; i < N_THREADS; i++) {
        // ğŸ†— thread_list.push_back(std::thread{do_some_work, i});
        // ğŸ†— thread_list.push_back(std::thread(do_some_work, i));
        thread_list.emplace_back(do_some_work, i);
    }
    std::cout << "work in main thread" << std::endl;

    // main() thread will waiting other threads
    for (int i = 0; i < N_THREADS; i++) {
        thread_list[i].join();
    }
    std::cout << "main thread end" << std::endl;
    return 0;
}
```

ä¸‰ä¸ªå­çº¿ç¨‹å…±äº«è¾“å‡ºç¼“å†²åŒº `std::cout`ï¼Œæ­¤æ—¶æ²¡æœ‰é‡‡å–ä»»ä½•æœºåˆ¶ä¿æŠ¤çº¿ç¨‹é—´å…±äº«æ•°æ®ï¼Œå› æ­¤ä¸Šé¢ demo çš„è¾“å‡ºå¯èƒ½ä¸ç¬¦åˆä½ çš„é¢„æœŸï¼Œå³å¾ˆå¯èƒ½ä¸æ˜¯æŒ‰ç…§å¦‚ä¸‹æ ¼å¼è¾“å‡ºï¼š

```bash
$ ./thread
thread: 0
thread: 1
thread: 2
```

å®é™…è¾“å‡ºç»“æœï¼ˆéå¸¸æ··ä¹±ï¼‰ï¼š

```bash
$ ./thread
thread: work in main thread
thread: 0
2
thread: 1
main thread end
```

ä»è¾“å‡ºå¯ä»¥çœ‹å‡ºï¼š

- å…ˆåˆ›å»ºçš„çº¿ç¨‹ï¼Œæœªå¿…å°±å…ˆè¿è¡Œï¼›
- è€Œä¸”å‡ ä¸ªçº¿ç¨‹ä¹‹é—´æ˜¯äº’ç›¸æŠ¢ CPU èµ„æºçš„

çº¿ç¨‹é—´æ•°æ®å…±äº«é—®é¢˜åŠå…¶åº”å¯¹æªæ–½ï¼Œç•™åˆ°åæ–‡è®²è§£ï¼Œä¸‹é¢è®²è§£ `std::thread` çš„è®¾è®¡ã€‚

### æ·±å…¥å‰–æ std::thread

**åœ¨ `g++` ä¸­ï¼Œ`thread` æ˜¯åŸºäº `pthread` å®ç°çš„**ã€‚æœ¬æ¬¡ä¸»è¦ä»ä»¥ä¸‹ä¸‰ä¸ªæ–¹é¢åˆ† `std::thread`ï¼š

- `std::thread` å¯¹è±¡ä¸å¯å¤åˆ¶ï¼Œåªå…·æœ‰ç§»åŠ¨å±æ€§
- æ¯ä¸ªçº¿ç¨‹å…·æœ‰å”¯ä¸€çš„æ ‡å¿—ï¼Œå³çº¿ç¨‹ id
- åˆ›å»ºå­çº¿ç¨‹ï¼ˆå³æ„é€  `std::thread`ï¼‰

#### 1. ç§»åŠ¨å±æ€§

æœ‰å¾ˆå¤šä¹¦ç±è¯´ï¼Œ`std::thread` å¯¹è±¡çš„æ‰€æœ‰æƒåªèƒ½ä¼ é€’ä¸èƒ½å¤åˆ¶ã€‚å®é™…ä¸Šï¼Œå°± `std::thread` å¯¹è±¡ï¼Œåªå…·æœ‰ç§»åŠ¨å±æ€§ï¼Œä¸å…·æœ‰å¤åˆ¶å±æ€§ã€‚`std::thread` çš„æ„é€ å‡½æ•°å¦‚ä¸‹ï¼š

```cpp
class thread {
   private:
    id _M_id;

   public:
    thread() noexcept = default;

    template <typename _Callable, typename... _Args, typename = _Require<__not_same<_Callable>>>
    explicit thread(_Callable&& __f, _Args&&... __args) {
        //...
    }

    ~thread() {
        if (joinable()) std::terminate();
    }
    // ç¦æ­¢å¤åˆ¶ï¼ˆå¤åˆ¶æ„é€ ã€å¤åˆ¶èµ‹å€¼ï¼‰
    thread(const thread&) = delete;
    thread& operator=(const thread&) = delete;

    // std::thread åªå…·æœ‰ç§»åŠ¨å±æ€§ï¼ˆç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼ï¼‰
    thread(thread&& __t) noexcept { swap(__t); }

    thread& operator=(thread&& __t) noexcept {
        if (joinable()) std::terminate();
        swap(__t);
        return *this;
    }
    //...
}
```

å¯ä»¥å‘ç°ï¼Œ`std::thread` ç¦æ­¢äº†å¤åˆ¶æ„é€ å‡½æ•°ã€å¤åˆ¶èµ‹å€¼è¡¨è¾¾å¼ï¼Œåªç•™ä¸‹äº†ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼ï¼Œä½¿å¾— `std::thread` å¯¹è±¡åªèƒ½ç§»åŠ¨ï¼Œä¸èƒ½å¤åˆ¶ã€‚è¿™å°±æ˜¯ä¹‹å‰ demo ä¸­ä½¿ç”¨ `emplace_back` å‡½æ•°æ·»åŠ  `std::thread` å¯¹è±¡çš„åŸå› ï¼Œé˜²æ­¢è§¦å‘å¤åˆ¶æ„é€ å‡½æ•°ã€‚æ‰€ä»¥å‘ thread_list ä¸­æ·»åŠ  `std::thread` å¯¹è±¡æœ‰ä»¥ä¸‹å‡ ç§æ–¹å¼ï¼š

> å½“ push_back æ¥å—çš„æ˜¯å³å€¼ï¼Œåº•å±‚è°ƒç”¨çš„è¿˜æ˜¯ emplace_back å‡½æ•°ï¼Œå› æ­¤ 4 å’Œ 5 æ˜¯ç­‰ä»·çš„ã€‚

```cpp
thread_list.push_back(std::thread{do_some_work, i});	// 1.ok

thread_list.emplace_back(do_some_work, i);	 			// 2.ok
thread_list.emplace_back(std::thread{do_some_work, i});	 // 2.ok

std::thread trd{do_some_work, i};
thread_list.push_back(trd);					// 3.errorâŒ

thread_list.push_back(std::move(trd));		 // 4.ok
thread_list.emplace_back(std::move(trd));	 // 5.ok
```

ç¬¬ä¸‰ç§åŠæ³•æŠ¥é”™ï¼š

```c++
/usr/include/c++/9/ext/new_allocator.h: In instantiation of â€˜void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::thread; _Args = {std::thread&}; _Tp = std::thread]â€™:
/usr/include/c++/9/bits/alloc_traits.h:483:4:   required from â€˜static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::thread; _Args = {std::thread&}; _Tp = std::thread; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread>]â€™
/usr/include/c++/9/bits/vector.tcc:115:30:   required from â€˜void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::thread&}; _Tp = std::thread; _Alloc = std::allocator<std::thread>]â€™
_thread.cpp:22:37:   required from here
/usr/include/c++/9/ext/new_allocator.h:146:4: error: use of deleted function â€˜std::thread::thread(const std::thread&)â€™
  146 |  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
      |    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from _thread.cpp:3:
/usr/include/c++/9/thread:142:5: note: declared here
  142 |     thread(const thread&) = delete;
```

#### 2. std::thread::id

å¯ä»¥å‘ç°ï¼Œåœ¨ `std::thread` å¯¹è±¡ä¸­ï¼Œåªæœ‰ä¸€ä¸ªæˆå‘˜å˜é‡ `_M_id`ã€‚

è¿™ä¸ªç±» id å…¨ç§°æ˜¯ `std::thread::id`ï¼Œå®ç°å¦‚ä¸‹ï¼š

```cpp
class id {
    // // _M_thread å³ pthread_t å¯¹è±¡ï¼Œçº¿ç¨‹çš„å”¯ä¸€è¾¨è¯†æ ‡å¿—
    native_handle_type _M_thread;

   public:
    // _M_thread é»˜è®¤å€¼æ˜¯ 0
    id() noexcept : _M_thread() {}

    explicit id(native_handle_type __id) : _M_thread(__id) {}

   private:
    friend class thread;
    friend class hash<thread::id>;
    // ä¸º std::thread::id å¯¹è±¡é‡è½½äº† == è¿ç®—
    friend bool operator==(thread::id __x, thread::id __y) noexcept;

    friend bool operator<(thread::id __x, thread::id __y) noexcept;
    // ä¸º std::thread::id å¯¹è±¡é‡è½½äº† << æ“ä½œ
    template <class _CharT, class _Traits>
    friend basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
};
```

å› æ­¤ï¼Œè¿™ä¸ª `std::thread::id` å®é™…ä¸Šå°±æ˜¯å°è£…äº† `pthread_t` å¯¹è±¡ï¼Œç”¨ä½œæ¯ä¸ªçº¿ç¨‹çš„æ ‡å¿—ã€‚

- åœ¨æ„é€  `std::thread` å¯¹è±¡çš„æ—¶å€™ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œåˆ™çº¿ç¨‹ `_M_id._M_thread` çš„å€¼æ˜¯ 0

æ¯”å¦‚ä¸‹é¢çš„ demoï¼Œ`trd` æ²¡æœ‰è®¾ç½®çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œ`trd` è°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°æ—¶ï¼Œ`trd` çš„ `_M_id._M_thread` ä¼šè¢«åˆå§‹åŒ–ä¸º 0

```cpp
int main(int argc, char const* argv[]) {
    std::thread trd;
    std::cout << trd.get_id() << std::endl;
    return 0;
}
```

ä½†æ˜¯ï¼Œæ‰“å°çº¿ç¨‹æ ‡å¿— `trd.get_id()`ï¼Œè¾“å‡ºçš„æ˜¯å´ä¸æ˜¯0ã€‚è¿™ä»…ä»…æ˜¯ `std::thread::id` åœ¨é‡è½½ `<<` æ“ä½œç¬¦æ—¶çš„è®¾å®šï¼Œç”¨äºæç¤ºè°ƒç”¨è€…çº¿ç¨‹æ²¡æœ‰å¯åŠ¨ã€‚

```bash
$ g++  thread_.cc -o thread_ && ./thread_
thread::id of a non-executing thread
```

å¯ä»¥åˆ° `std::thread::id` é‡è½½çš„ `<<` æ“ä½œç¬¦çš„å‡½æ•°ä¸­ä¸€æ¢ç©¶ç«Ÿï¼š

```cpp
template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>& operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id) {
    // çº¿ç¨‹æœªå¯åŠ¨ 
    if (__id == thread::id())
    return __out << "thread::id of a non-executing thread";
    // çº¿ç¨‹æˆåŠŸå¯åŠ¨
    else
    return __out << __id._M_thread;
}

// idçš„ç›¸ç­‰åˆ¤æ–­ 
inline bool operator==(thread::id __x, thread::id __y) noexcept {
    return __x._M_thread == __y._M_thread;
}
```

å› æ­¤åˆ¤æ–­ä¸€ä¸ªçº¿ç¨‹æ˜¯å¦å¯åŠ¨ï¼Œå¯å¦‚ä¸‹æ£€æµ‹ï¼š

```cpp
bool thread_is_active(const std::thread::id& thread_id) { 
    return thread_id != std::thread::id();
}
```

è®¾ç½®äº†çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œ`_M_id._M_thread` æ‰æ˜¯çº¿ç¨‹çš„`tid`å€¼ï¼Œç”± `pthread_create(&tid, NULL, ...)` å‡½æ•°è®¾ç½®ï¼š

```cpp
int main(int argc, char const* argv[]) {
    std::thread trd{[] { std::cout << "work in sub-thread\n"; }};

    std::cout << trd.get_id() << std::endl;
    trd.join();
    return 0;
}
```

```bash
$ ./thread 
140203273147968
work in sub-thread
```

**by the way**

åœ¨åˆ›å»º `std::thread` å¯¹è±¡ `trd` æ—¶ï¼š

- **å¦‚æœè®¾ç½®äº†çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œé‚£ä¹ˆå°±å¿…é¡»ä½¿ç”¨ `trd.join()` æˆ–è€… `trd.detach()` æ¥è¡¨è¾¾å­çº¿ç¨‹ä¸ä¸»çº¿ç¨‹çš„è¿è¡Œå…³ç³»ï¼Œå¦åˆ™åœ¨ `std::thread` å¯¹è±¡ææ„æ—¶ï¼Œæ•´ä¸ªç¨‹åºä¼šè¢« `std::terminate()` ä¸­æ­¢**ã€‚
- å¦‚æœæ²¡æœ‰è®¾ç½®çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œ`trd.joinable()` è¿”å›å€¼å°±æ˜¯ `false`ï¼Œå› æ­¤ä¸ä¼šè§¦å‘ `std::terminate()`ã€‚

```cpp
~thread() {
  if (joinable())
    std::terminate();
}
```

#### 3. åˆ›å»ºå­çº¿ç¨‹

å½“æ„é€  `std::thread` å¯¹è±¡æ—¶ï¼Œè®¾ç½®äº†çº¿ç¨‹å…¥å£å‡½æ•°ï¼Œä¼šåœ¨ç›¸åŒ¹é…çš„æ„é€ å‡½æ•°é‡Œè°ƒç”¨ `pthread_create` å‡½æ•°åˆ›å»ºå­çº¿ç¨‹ã€‚å…ˆçœ‹æ•´ä½“å®ç°ï¼š

```cpp
// std::thread æ„é€ å‡½æ•°
template<typename _Callable, 
         typename... _Args,
         typename = _Require<__not_same<_Callable>>>
explicit thread(_Callable&& __f, _Args&&... __args)
{
    static_assert( __is_invocable<typename decay<_Callable>::type, 
                                  typename decay<_Args>::type...>::value,
                  "std::thread arguments must be invocable after conversion to rvalues");

    // Create a reference to pthread_create, not just the gthr weak symbol.
    auto __depend = reinterpret_cast<void(*)()>(&pthread_create);
    // å¯åŠ¨çº¿ç¨‹
    _M_start_thread(_S_make_state(__make_invoker(std::forward<_Callable>(__f), 
                                                 std::forward<_Args>(__args)...)),
                    __depend);
}
```

å†ç»†çœ‹æ„é€ å‡½æ•°æ‰§è¡Œæµç¨‹ï¼š

1. åœ¨ç¼–è¯‘æœŸåˆ¤æ–­æ„é€  `std::thread` å¯¹è±¡æ—¶è®¾ç½®çš„çº¿ç¨‹å…¥å£å‡½æ•° `__f` åŠå…¶å‚æ•° `__args` èƒ½å¦è°ƒç”¨ã€‚

æ¯”å¦‚ï¼Œä¸‹é¢çš„ demo ä¸­ï¼Œçº¿ç¨‹å…¥å£å‡½æ•° `thread_func` æœ‰ä¸ª `int` ç±»å‹çš„å‚æ•° `arg`ï¼Œå¦‚æœä¼ å…¥çš„å‚æ•° `__args` æ— æ³•éšå¼è½¬æ¢ä¸º `int` ç±»å‹ï¼Œæˆ–è€…æ²¡æœ‰è®¾ç½® `__args`ï¼Œéƒ½ä¼šè§¦å‘ `std::thread` æ„é€ å‡½æ•°ä¸­çš„é™æ€æ–­è¨€ `static_assert`ã€‚

> æŠ¥é”™ï¼š**error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues**

```cpp
void thread_func(int arg) { }

int main(int argc, char const *argv[]) {
    std::thread trd_1{thread_func, "str"};  // arg ç±»å‹ä¸å¯¹
    std::thread trd_2{thread_func};	 	    // ç¼ºå°‘ arg

    // ...
    return 0;
}
```

2. å°†çº¿ç¨‹å…¥å£å‡½æ•° `__f` åŠå…¶å‚æ•° `__args` è¿›ä¸€æ­¥å°è£…èµ·æ¥ã€‚

è¿™é‡Œæ˜¯ä½¿ç”¨ `__make_invoker` å®Œæˆçš„ï¼š

```cpp
__make_invoker(std::forward<_Callable>(__f), std::forward<_Args>(__args)...);
```

`__make_invoker` çš„ä½œç”¨æ˜¯è¿”å›ä¸€ä¸ª `_Invoker` å¯¹è±¡ï¼Œ**`_Invoker` æ˜¯ä¸ªä»¿å‡½æ•°ï¼Œé€šè¿‡ `_Invoker()` å°±å¯ä»¥ä»¥æŒ‡å®šçš„å‚æ•° `__args` ç›´æ¥æ‰§è¡Œçº¿ç¨‹å…¥å£å‡½æ•° `__f`**ã€‚ç±»ä¼¼äº `std::bind`ï¼š

```cpp
 void print_num(int i) {
     std::cout << i << '\n';
 }

 int main(int argc, const char* argv[]) {
    // wrapper
    auto invoker =  std::bind(print_num, -9);
    // ç›´æ¥è°ƒç”¨ invoker() å°±å¯ä»¥ä»¥æŒ‡å®šå‚æ•° -9 è°ƒç”¨ print_num
    invoker();
 }
```

3. å¯åŠ¨å­çº¿ç¨‹

åœ¨è°ƒç”¨ `_M_start_thread` å‡½æ•°å¯åŠ¨å­çº¿ç¨‹å‰ï¼Œæ‰§è¡Œè¿‡ç¨‹ï¼š

- åˆ›å»º `_State_ptr` çš„å¯¹è±¡ï¼Œæ¥å°è£… `_Invoker` å¯¹è±¡ï¼Œå†ä¼ é€’ç»™ `_M_start_thread` å‡½æ•°ã€‚
- ä¼ é€’ `_M_start_thread` å‡½æ•°çš„è¿‡ç¨‹ï¼Œç”± `_S_make_state` å‡½æ•°å®Œæˆï¼Œ`_S_make_state` æœ€ç»ˆè¿”å› `_State_ptr` å¯¹è±¡ã€‚

```cpp
// åŸºç±»
struct _State {
   virtual ~_State();          // è™šææ„å‡½æ•°
   virtual void _M_run() = 0;  // çº¿ç¨‹è¿è¡Œå‡½æ•°
};
using _State_ptr = unique_ptr<_State>;	// çˆ¶ç±»æŒ‡é’ˆ

// å­ç±»
template<typename _Callable>
struct _State_impl : public _State {
   _Callable		_M_func;	// çº¿ç¨‹å…¥å£å‡½æ•°

   _State_impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
   { }

   void _M_run() { _M_func(); } // æ‰§è¡Œçº¿ç¨‹å…¥å£å‡½æ•°
};

// ä¼ å…¥_Invokerå¯¹è±¡ï¼Œè¿”å› _State_ptr å¯¹è±¡
template<typename _Callable>
static _State_ptr _S_make_state(_Callable&& __f)  {
   using _Impl = _State_impl<_Callable>;
   // ä½¿ç”¨å­ç±»å¯¹è±¡æ¥åˆå§‹åŒ–çˆ¶ç±»
   return _State_ptr{new _Impl{std::forward<_Callable>(__f)}};
}
```

`_S_make_state` å‡½æ•°ï¼Œå°†çº¿ç¨‹å…¥å£å‡½æ•° `__f` åŠå…¶å‚æ•° `__args` å°è£…åˆ° `_State_ptr` å¯¹è±¡ `_State_ptr_obj` ä¸­ï¼Œ è¿™æ ·æœ€åå¯ä»¥é€šè¿‡ `_State_ptr_obj->_M_run()` æ¥è°ƒç”¨ `__f`ã€‚

ä¸‹é¢åˆ°äº† `_M_start_thread` å‡½æ•°ï¼š

```cpp
void thread::_M_start_thread(_State_ptr state, void (*)())
{
  const int err = __gthread_create(&_M_id._M_thread,
                                    &execute_native_thread_routine, // çº¿ç¨‹æ‰§è¡Œå‡½æ•°
                                    state.get());
  if (err)
    __throw_system_error(err);
  state.release();
}

// å†…éƒ¨è°ƒç”¨çš„æ˜¯ pthread_create å‡½æ•°
static inline int __gthread_create(pthread_t *__threadid, void *(*__func) (void*), void *__args)
{
  return pthread_create(__threadid, NULL, __func, __args);
}

// å†…éƒ¨æ‰§è¡Œçº¿ç¨‹å…¥å£å‡½æ•°
static void* execute_native_thread_routine(void* __p)
{
  thread::_State_ptr __t{static_cast<thread::_State*>(__p)};
  __t->_M_run();		// è¿è¡Œçº¿ç¨‹å…¥å£å‡½æ•°
  return nullptr;
}
```

å› æ­¤ï¼Œåœ¨æ‰§è¡Œå®Œ `_M_start_thread` å‡½æ•°åï¼Œæ‰å…·æœ‰ `_M_start_thread != 0`ã€‚

### Mutex

æœ‰æ—¶å€™éœ€è¦é™åˆ¶å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€èµ„æºçš„è®¿é—®ï¼Œè¿™æ—¶å€™ä¸€èˆ¬ä¼šä½¿ç”¨ `Mutex`ã€‚Mutex å°±æ˜¯ä¸€æŠŠé”ï¼Œåªæœ‰æŸäº›çº¿ç¨‹å¯ä»¥åŒæ—¶å ç”¨å®ƒï¼ˆé€šè¿‡ lock æ“ä½œï¼‰ã€‚å½“çº¿ç¨‹ä¸ç”¨çš„æ—¶å€™ï¼Œå°±å¾—é€šè¿‡ unlock æ“ä½œæ¥é‡Šæ”¾å®ƒã€‚

å¯¹äº Mutexï¼Œ`std::thread` å’Œ `pthread` å·®ä¸å¤šï¼Œæ— éæ˜¯ `pthread_mutex_lock(&mutex)` å˜æˆäº† `mutex.lock()` ç­‰ç­‰ã€‚

**ä¸è¿‡åœ¨ `std::thread` ä¸­ï¼Œmutex å¾€å¾€å’Œ lock ç³»åˆ—æ¨¡æ¿ä¸€èµ·ä½¿ç”¨ã€‚è¿™æ˜¯å› ä¸º lock ç³»åˆ—æ¨¡æ¿åŒ…è£…äº† mutex ç±»ï¼Œæä¾›äº† RAII é£æ ¼çš„åŠ é”è§£é”**ã€‚

```cpp
{
    // åŠ é”
    std::lock_guard<std::mutex> guard(mutex);
    ...

    // è‡ªåŠ¨è§£é”
}
```

mutex æœ‰å››ç§ï¼š

- `std::mutex`ï¼šç‹¬å çš„äº’æ–¥é‡ï¼Œä¸èƒ½é€’å½’ä½¿ç”¨ï¼Œä¸å¸¦è¶…æ—¶åŠŸèƒ½
- `std::recursive_mutex`ï¼šé€’å½’äº’æ–¥é‡ï¼Œå¯é‡å…¥ï¼Œä¸å¸¦è¶…æ—¶åŠŸèƒ½
- `std::timed_mutex`ï¼šå¸¦è¶…æ—¶çš„äº’æ–¥é‡ï¼Œä¸èƒ½é€’å½’
- `std::recursive_timed_mutex`ï¼šå¸¦è¶…æ—¶çš„äº’æ–¥é‡ï¼Œå¯ä»¥é€’å½’ä½¿ç”¨

åŠ è§£é”æ–¹å¼æœ‰ä¸‰ç§ï¼š

- `std::lock_guard`ï¼šå¯ä»¥RAIIæ–¹å¼åŠ é”
- `std::unique_lock`ï¼šæ¯” `lock_guard` å¤šäº†ä¸ªæ‰‹åŠ¨åŠ è§£é”çš„åŠŸèƒ½
- `std::scoped_lock`ï¼šé˜²æ­¢å¤šä¸ªé”é¡ºåºé—®é¢˜å¯¼è‡´çš„æ­»é”é—®é¢˜è€Œå‡ºä¸–çš„ä¸€æŠŠé”

### Condition Variable

æœ‰æ—¶å€™çº¿ç¨‹ä¹‹é—´éœ€è¦æŸç§åŒæ­¥ï¼šå½“æŸäº›æ¡ä»¶ä¸æ»¡è¶³æ—¶ï¼Œåœæ­¢æ‰§è¡Œç›´åˆ°è¯¥æ¡ä»¶è¢«æ»¡è¶³ã€‚

è¿™æ—¶å€™éœ€è¦å¼•å…¥ condition variable â€”â€” çŠ¶æ€å˜é‡ã€‚

åœ¨ç»å…¸çš„ã€Œç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å¼ã€ä¸‹ï¼Œç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å°±æ˜¯é€šè¿‡ condition variable æ¥å®ç°åŒæ­¥çš„ã€‚

> å½“æœ‰é™çš„ç”Ÿäº§åŠ›æ— æ³•æ»¡è¶³æ—¥ç›Šå¢é•¿çš„æ¶ˆè´¹éœ€æ±‚æ—¶ï¼Œæ¶ˆè´¹è€…è¿›ç¨‹å°±ä¼šå»ç¡ä¸€è§‰ï¼Œç›´åˆ°å®ƒæƒ³è¦çš„ä¸œè¥¿ç”Ÿäº§å‡ºæ¥æ‰é†’æ¥ã€‚

```cpp
std::condition_variable condvar;

consumer:
        std::unique_lock<std::mutex> ulock(mutex);
        condvar.wait(ulock, []{ return msgQueue.size() > 0;});

producer:
        condvar.notify_all();
```

- `condition_variable` éœ€è¦å’Œ `unique_lock` æ­é…ä½¿ç”¨
- åœ¨ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ `wait` ä¹‹å‰ï¼Œå®ƒå¿…é¡»æŒæœ‰ `unique_lock` é”
- å½“  `wait`  è¢«è°ƒç”¨æ—¶ï¼Œè¯¥é”ä¼šè¢«é‡Šæ”¾ï¼Œçº¿ç¨‹ä¼šé™·å…¥æ²‰ç¡ï¼Œç­‰å¾…ç€ç”Ÿäº§è€…å‘è¿‡æ¥çš„å”¤é†’ä¿¡å·
- å½“ç”Ÿäº§è€…è°ƒç”¨åŒä¸€ä¸ª `condition_variable` çš„ `notify_all` æ–¹æ³•æ—¶ï¼Œæ‰€æœ‰æ²‰ç¡åœ¨è¯¥å˜é‡å‰çš„æ¶ˆè´¹è€…ä¼šè¢«å”¤é†’ï¼Œå¹¶å°è¯•é‡æ–°è·å–ä¹‹å‰é‡Šæ”¾çš„ `unique_lock`ï¼Œç»§ç»­æ‰§è¡Œä¸‹å»ï¼ˆæ³¨æ„è¿™é‡Œå‘ç”Ÿäº†é”äº‰ç”¨ï¼Œåªæœ‰ä¸€ä¸ªæ¶ˆè´¹è€…èƒ½å¤Ÿè·å¾—é”ï¼Œå…¶ä»–æ¶ˆè´¹è€…å¾—ç­‰å¾…è¯¥æ¶ˆè´¹è€…é‡Šæ”¾é”ï¼‰
- å¦‚æœåªæƒ³å«é†’ä¸€ä¸ªçº¿ç¨‹ï¼Œå¯ä»¥ç”¨ `notify_one`
- `pthread` ä¸­ä¹Ÿæä¾›äº†å¯¹åº”çš„æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ `pthread_cond_wait`, `pthread_cond_broadcast`, `pthread_cond_signal`

`wait`  å¯ä»¥æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œæ­¤æ—¶ç¬¬äºŒä¸ªå‚æ•°ç”¨äºåˆ¤æ–­å½“å‰æ˜¯å¦è¦æ²‰ç¡ã€‚

```cpp
[]{ return msgQueue.size() > 0;});
```

ç›¸å½“äº

```cpp
while (msgQueue.size() <= 0) {
    condvar.wait()
}
```

ä¸ºäº†é˜²æ­¢çº¿ç¨‹æ— é™ç­‰å¾…ï¼ˆå¯èƒ½ä¸€ç›´æ²¡æœ‰å”¤é†’ï¼‰ï¼Œé€šè¿‡ `wait_until` å’Œ `wait_for`ï¼Œä½ å¯ä»¥è®¾å®šçº¿ç¨‹çš„ç­‰å¾…æ—¶é—´ã€‚è®¾ç½® `notify_all_at_thread_exit` ä¹Ÿè®¸èƒ½å¸®å¾—ä¸Šå¿™ã€‚

åœ¨ `pthread` ä¸­ï¼Œå¯¹åº”çš„è°ƒç”¨æ˜¯ `pthread_cond_timedwait`ã€‚

### More

C++11 çš„çº¿ç¨‹åº“è¿˜æä¾›äº†å…¶ä»–å¤šçº¿ç¨‹ç¼–ç¨‹çš„æ¦‚å¿µï¼Œæ¯”å¦‚ `future` å’Œ `atomic`ã€‚

#### future

future ä½äºå¤´æ–‡ä»¶ `<future>` ä¸‹ï¼ŒåŒ…è£…äº†æœªæ¥æŸä¸ªè®¡ç®—ç»“æœçš„æœŸè¯ºã€‚

å½“ä½ å¯¹æ‰€è·å¾—çš„ `future` è°ƒç”¨ `get` æ—¶ï¼Œç¨‹åºä¼šä¸€ç›´é˜»å¡ç›´åˆ° future çš„å€¼è¢«è®¡ç®—å‡ºæ¥ï¼ˆå¦‚æœ future çš„å€¼å·²ç»è®¡ç®—å‡ºæ¥äº†ï¼Œget è°ƒç”¨ä¼šç«‹åˆ»è·å¾—è¿”å›å€¼ï¼‰ï¼Œè€Œè¿™ä¸€åˆ‡éƒ½æ˜¯åœ¨åå°æ‰§è¡Œçš„ã€‚

```cpp
#include <chrono>
#include <iostream>
#include <future>

using namespace std;

int main()
{
    future<int> f1 = async(launch::async, [](){
        std::chrono::milliseconds dura(2000);
        std::this_thread::sleep_for(dura);
        return 0; 
    });
    
    future<int> f2 = async(launch::async, [](){
        std::chrono::milliseconds dura(2000);
        std::this_thread::sleep_for(dura);
        return 1; 
    });
    
    cout << "Results are: " << f1.get() << " " << f2.get() << "\n";
    return 0;
}
```

```bash
$ g++ -std=c++11 -pthread ./future.cpp

$ time ./a.out 
Results are: 0 1
./a.out  0.00s user 0.00s system 0% cpu 2.012 total # æ˜¯ä¸¤ç§’å·¦å³è€Œä¸æ˜¯å››ç§’
```

é™¤äº† `async`ï¼Œ `packaged_task` å’Œ `promise` ä¹Ÿéƒ½è¿”å›ä¸€ä¸ª `future`ã€‚

#### atomic

`atomic` ä½äºå¤´æ–‡ä»¶ `<atomic>`  ä¸‹ï¼Œå®ç°äº†ç±»ä¼¼äº `java.util.concurrent.atomic` çš„åŠŸèƒ½ã€‚å®ƒæä¾›äº†ä¸€ç»„è½»é‡çº§çš„ã€ä½œç”¨åœ¨å•ä¸ªå˜é‡ä¸Šçš„åŸå­æ“ä½œï¼Œæ˜¯ `volatile` çš„æ›¿ä»£å“ï¼Œæœ‰äº›æ—¶å€™ä½ ä¹Ÿå¯ä»¥ç”¨å®ƒæ¥æ›¿æ¢æ‰ `lock`ï¼ˆå‡å¦‚æ•´ä¸ª race condition ä¸­åªæœ‰å•ä¸ªå˜é‡ï¼‰

ä¸‹é¢è¿™ä¸ªä¾‹å­è§£é‡Šäº†ä»€ä¹ˆå«åšåŸå­æ“ä½œï¼š

```cpp
#include <atomic>
#include <iostream>
#include <thread>

using namespace std;

const int NUM = 100;

int target = 0;
atomic<int> atomicTarget(0);

template<typename T>
void atomicPlusOne(int trys)
{
    while (trys > 0) {
        atomicTarget.fetch_add(1);
        --trys;
    }
}

void plusOne(int trys)
{
    while (trys > 0) {
        ++target;
        --trys;
    }
}

int main()
{
    thread threads[NUM];
    thread atomicThreads[NUM];
    for (int i = 0; i < NUM; i++) {
        atomicThreads[i] = thread(atomicPlusOne<int>, 10000);
    }
    for (int i = 0; i < NUM; i++) {
        threads[i] = thread(plusOne, 10000);
    }

    for (int i = 0; i < NUM; i++) {
        atomicThreads[i].join();
    }
    for (int i = 0; i < NUM; i++) {
        threads[i].join();
    }

    cout << "Atomic target's value : " << atomicTarget << "\n";
    cout << "Non-atomic target's value : " << target << "\n";

    return 0;
}
```

```bash
# atomicTarget çš„å€¼æ€»æ˜¯å›ºå®šçš„ï¼Œè€Œ target çš„å€¼æ¯æ¬¡è¿è¡Œæ—¶å„ä¸ç›¸åŒ
$ g++ -std=c++11 -pthread ./atom.cpp
Atomic target's value : 1000000
Non-atomic target's value : 842480
```

## Pros & Cons

æœ€åæ€»ç»“ä¸‹ `std::thread` å¯¹æ¯”äº `pthread` çš„ä¼˜ç¼ºç‚¹ï¼š

ä¼˜ç‚¹ï¼š

1. ç®€å•ï¼Œæ˜“ç”¨
2. è·¨å¹³å°ï¼Œ`pthread` åªèƒ½ç”¨åœ¨ POSIX ç³»ç»Ÿä¸Šï¼ˆå…¶ä»–ç³»ç»Ÿæœ‰å…¶ç‹¬ç«‹çš„ thread å®ç°ï¼‰
3. æä¾›äº†æ›´å¤šé«˜çº§åŠŸèƒ½ï¼Œæ¯”å¦‚ `future`
4. æ›´åŠ  C++ï¼ˆä¸**åŒ¿åå‡½æ•°**ï¼Œ`std::bind`ï¼ŒRAII ç­‰ C++ ç‰¹æ€§æ›´å¥½çš„é›†æˆï¼‰

ç¼ºç‚¹ï¼š

1. æ²¡æœ‰ RWlockï¼šæœ‰ä¸€ä¸ªç±»ä¼¼çš„ `shared_mutex`ï¼Œä¸è¿‡å®ƒå±äº C++14ï¼Œä½ çš„ç¼–è¯‘å™¨å¾ˆæœ‰å¯èƒ½ä¸æ”¯æŒ
2. æ“ä½œçº¿ç¨‹å’Œ Mutex ç­‰çš„ API è¾ƒå°‘ï¼šæ¯•ç«Ÿä¸ºäº†è·¨å¹³å°ï¼Œåªèƒ½é€‰å–å„åŸç”Ÿå®ç°çš„å­é›†ã€‚å¦‚æœä½ éœ€è¦è®¾ç½®æŸäº›å±æ€§ï¼Œéœ€è¦é€šè¿‡ API è°ƒç”¨è¿”å›åŸç”Ÿå¹³å°ä¸Šçš„å¯¹åº”å¯¹è±¡ï¼Œå†å¯¹è¿”å›çš„å¯¹è±¡è¿›è¡Œæ“ä½œã€‚

## ç”Ÿäº§è€…æ¶ˆè´¹è€…ï¼ˆpthread & thread ç‰ˆæœ¬ï¼‰

é™„ä¸Šæˆ‘è‡ªå·±å†™çš„ï¼Œåˆ†åˆ«ç”¨ `std::thread` å’Œ `pthread` å®ç°çš„å¤šç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ç¨‹åºã€‚

> æ³¨æ„è¡Œæ•°ä¸Šçš„å·®è·ã€‚

### pthread ç‰ˆæœ¬

```c
#include <pthread.h>
#include <queue>
#include <stdio.h>
#include <unistd.h>

// æ³¨æ„ pthread_* å‡½æ•°è¿”å›çš„å¼‚å¸¸å€¼ï¼Œä¸ºäº†ç®€å•ï¼ˆå·æ‡’ï¼‰ï¼Œæˆ‘æ²¡æœ‰å»å¤„ç†å®ƒä»¬

pthread_mutex_t mutex;
pthread_cond_t condvar;

std::queue<int> msgQueue;
struct Produce_range {
    int start;
    int end;
};

void *producer(void *args)
{
    int start = static_cast<Produce_range *>(args)->start;
    int end = static_cast<Produce_range *>(args)->end;
    for (int x = start; x < end; x++) {
        usleep(200 * 1000);
        pthread_mutex_lock(&mutex);
        msgQueue.push(x);
        pthread_mutex_unlock(&mutex);
        pthread_cond_signal(&condvar);
        printf("Produce message %d\n", x);
    }
    pthread_exit((void *)0);
    return NULL;
}

void *consumer(void *args)
{
    int demand = *static_cast<int *>(args);
    while (true) {
        pthread_mutex_lock(&mutex);
        if (msgQueue.size() <= 0) {
            pthread_cond_wait(&condvar, &mutex);
        }
        if (msgQueue.size() > 0) {
            printf("Consume message %d\n", msgQueue.front());
            msgQueue.pop();
            --demand;
        }
        pthread_mutex_unlock(&mutex);
        if (!demand) break;
    }
    pthread_exit((void *)0);
    return NULL;
}


int main()
{
    pthread_attr_t attr;
    pthread_attr_init(&attr);
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&condvar, NULL);

    pthread_t producer1, producer2, producer3, consumer1, consumer2;

    Produce_range range1 = {0, 10};
    pthread_create(&producer1, &attr, producer, static_cast<void *>(&range1));
    Produce_range range2 = {range1.end, range1.end + 10};
    pthread_create(&producer2, &attr, producer, static_cast<void *>(&range2));
    Produce_range range3 = {range2.end, range2.end + 10};
    pthread_create(&producer3, &attr, producer, static_cast<void *>(&range3));

    int consume_demand1 = 20;
    int consume_demand2 = 10;
    pthread_create(&consumer1, &attr, consumer, static_cast<void *>(&consume_demand1));
    pthread_create(&consumer2, &attr, consumer, static_cast<void *>(&consume_demand2));

    pthread_join(producer1, NULL);
    pthread_join(producer2, NULL);
    pthread_join(producer3, NULL);
    pthread_join(consumer1, NULL);
    pthread_join(consumer2, NULL);
}
```

### std::thread ç‰ˆæœ¬

```cpp
#include <chrono>
#include <condition_variable>
#include <future>
#include <mutex>
#include <queue>

// æ³¨æ„æŸäº›è°ƒç”¨å¯èƒ½ä¼šæŠ›å‡ºstd::system_errorï¼Œ ä¸ºäº†ç®€å•ï¼ˆå·æ‡’ï¼‰ï¼Œæˆ‘æ²¡æœ‰å»æ•è·
std::mutex mutex;
std::condition_variable condvar;

std::queue<int> msgQueue;

void producer(int start, int end)
{
    for (int x = start; x < end; x++) {
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
        {        
            std::lock_guard<std::mutex> guard(mutex);
            msgQueue.push(x);
        }
        printf("Produce message %d\n", x);
        condvar.notify_all();
    }
}

void consumer(int demand)
{
    while (true) {
        std::unique_lock<std::mutex> ulock(mutex);
        condvar.wait(ulock, []{ return msgQueue.size() > 0;});
        // waitçš„ç¬¬äºŒä¸ªå‚æ•°ä½¿å¾—æ˜¾å¼çš„double checkä¸å†å¿…è¦
        printf("Consume message %d\n", msgQueue.front());
        msgQueue.pop();
        --demand;
        if (!demand) break;
    }
}


int main()
{
    std::thread producer1(producer, 0, 10);
    std::thread producer2(producer, 10, 20);
    std::thread producer3(producer, 20, 30);
    std::thread consumer1(consumer, 20);
    std::thread consumer2(consumer, 10);

    producer1.join();
    producer2.join();
    producer3.join();
    consumer1.join();
    consumer2.join();
} 
```