---
title: Modern C++
description: Modern C++ Lecture
publishDate: 2025-04-12
tags: [cpp]
language: English
comment: true
draft: false
---

Link: [Modern C++ (Lecture & Tutorials, 2020, Vizzo & Stachniss) - University of Bonn](https://www.youtube.com/playlist?list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA)

## CMakeï½œBuild Systemï½œlibrary

âœ… [Modern C++: The Basics (Lecture 0, I. Vizzo, 2020)](https://www.youtube.com/watch?v=2xlk4bSPG38&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=2)ï¼šç®€å•çš„ Linux å’Œ Cpp å†å²å’Œæ•™ç¨‹

âœ… [Modern C++: Build and Tools (Lecture 1, I. Vizzo, 2020)](https://www.youtube.com/watch?v=9mZw6Rwz1vg&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=5)ï¼šå­¦ä¹ äº† cpp build system æ•´ä¸ªæµç¨‹ï¼ˆåŒ…æ‹¬ä½¿ç”¨ cmake ç”Ÿæˆ makefile ä»¥åŠ CMAKE çš„è¯­æ³•ï¼‰ã€é™æ€åº“/åŠ¨æ€åº“ï¼ˆ`lib*.a` ä¸ `lib*.so`ï¼‰


```shell
# å¯ä»¥è‡ªå·±å†™ library ç„¶åè‡ªå·±è¿½åŠ 
# compile modules
c++ -std=c++17 -c tools.cpp -o tools.o
# organize modules into libraries
# "ar rcs libname.a module.o module.o ..."
ar rcs libtools.a tools.o <other_modules>
# link libraries when building code
c++ -std=c++17 main.cpp -L . -ltools -o main
```

```cmake
# Use CMake to simplify the build
# CMakeLists.txt
cmake_minimum_required(VERSION 3.1)
project(first_project)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "-Wall")

# è¿™ä¸ªå‘½ä»¤å¯ä»¥å°†æ„å»ºç³»ç»Ÿçš„æ•´ä¸ªè„šæœ¬è¿‡ç¨‹è¾“å‡ºåˆ°å½“å‰ç›®å½•ä¸‹
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)	# important!
# tell cmake where to look for *.hpp *.h files
include_directories(include/)

# create library "libtools"
add_library(tools src/tools.cpp)	# create libtools.a

# add executable main
add_executable(main src/main.cpp)	# main.o

# tell the linker to bind these objects together
target_link_libraries(main tools)	# ./main
```

```shell
# Build a CMake project (Build process)
cd <project_folder>
mkdir build && cd build
cmake ..
make
```

## strtokï½œstringstream

âœ… [Modern C++: Core C++ (Lecture 2, I. Vizzo, 2020)](https://www.youtube.com/watch?v=0Jqwxr7vER4&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=7)

```cpp
#include <iomanip>
#include <iostream>
#include <sstream>

using namespace std;

int main() {
  stringstream filename("00205.txt");

  int num = 0;
  string ext;

  // Split the string stream using simple syntax
  // è€Œä¸æ˜¯ä½¿ç”¨ strtok æ¥åˆ†å‰²å­—ç¬¦ä¸²
  filename >> num >> ext;

  cout << num << endl;
  cout << ext << endl;

  return 0;
}
```

> `int main(int argc, char const *argv[]);`

`argc` defines number of input parameters

`argv` is an array of string parameters

By **default**:

- `argc == 1`
- `argv == "<binary_path>"`

## C++ Functions

âœ… [Modern C++: C++ Functions (Lecture 3, I. Vizzo, 2020)](https://www.youtube.com/watch?v=b1VdTKNEbrk&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=8)

C++ 17 å¯ä»¥åƒ Python è¿”å›å¤šä¸ªç±»å‹ä¸€æ ·ï¼Œè¿”å›å¤šç§å€¼äº† â€”â€” `tuple`

```cpp
#include <iostream>
#include <tuple>
using namespace std;

auto Foo() {
  return make_tuple("Super Variable", 19);
}

int main() {
  auto [name, age] = Foo();
  cout << name << " is " << age << " years old." << endl;
}
```

**WARNING**: Never return reference to locally variables!!!

```cpp
#include <iostream>
using namespace std;

int& MultiplyBy10(int num) {   // retval is created
  int retval = 0;
  retval = 10 * num;
  cout << "retval is " << retval << endl;   // åŠ ä¸Šè¿™è¡Œä»£ç åï¼Œg++ -O3 test.cpp -o test å°±å¯ä»¥æ­£å¸¸å·¥ä½œï¼›åä¹‹åˆ™è¾“å‡ºä¹±æ•°
  return retval;
} // retval is destroyed, it's not accesisble anymore

int main() {
  int out = MultiplyBy10(5);
  cout << out << endl;
  return 0;
}
```

è¿”å›äº†ä¸€ä¸ªæŒ‡å‘å·²ç»è¢«é”€æ¯çš„å†…å­˜ä½ç½®çš„å¼•ç”¨ï¼Œè®¿é—®è¿™ä¸ªå¼•ç”¨ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚`g++ -O3 test.cpp -o test` åˆ™ä¼šè¾“å‡ºé”™è¯¯çš„å€¼ï¼Œä¸åŠ  `-O3` åˆ™æ­£å¸¸ï¼Œæˆ–è€…è¯´åœ¨æ–¹æ³•ä¸­åŠ ä¸ª `cout` è¾“å‡ºåˆ™ä¹Ÿæ­£å¸¸ã€‚

Staticï¼šå‘ç”Ÿåœ¨ã€Œç¼–è¯‘ã€æ—¶

Non-Staticï¼šå‘ç”Ÿåœ¨ã€Œè¿è¡Œã€æ—¶

### inline function

- `function` calls are expensive...
- If the function is rather small, you could help the compiler.
- `inline` is a **hint** to the compiler
    - should attempt to generate code for a call.
    - rather than a function call.
- æ€»ç»“ï¼šå½“å‡½æ•°è¶³å¤Ÿå°çš„æ—¶å€™ï¼Œå¯ä»¥ç”¨ `inline` æ¥å†…è”å‡½æ•°ï¼Œå¸®åŠ©ç¼–è¯‘å™¨ä¸ºä½ ä¼˜åŒ–å®ƒ â€”â€” å³å½“å‡½æ•°è°ƒç”¨æ—¶ï¼Œç›´æ¥å°†ä»£ç æ”¾ï¼ˆæ›¿æ¢ï¼‰åˆ°å¯¹åº”ä½ç½®ï¼Œè€Œä¸æ˜¯è°ƒç”¨ã€‚

Check it out: https://godbolt.org/z/EGd6aG

## Good C++ Practices

- [ ] Break up complicated computations into meaningful chunks and name them.
- [ ] Keep the length of functions small enough.
- [ ] Avoid unecessary comments.
- [ ] One function shouldl achieve **ONE** task.
- [ ] If you can't pick a short name, then **split** functionallity.
- [ ] Avoid **macros**: If you must use ig, use ugly names with lots of capital letters.

## C++ Namespace

- Helps avoiding name conflicts
- Group the project into logical modules

**Avoid `using namespace <name>`**ï¼šå¥½æ¯”å†™ç®—æ³•æ—¶æ€»æ˜¯ä½¿ç”¨ `using namespace std;`ï¼Œè¿™æ˜¯éœ€è¦é¿å…çš„ï¼

```cpp
#include <cmath>
#include <iostream>

// Avoiding!!!
using namespace std;  // std namespace is used

// Self-defined function power shadows the std::pow
double pow(double x, int exp) {
  double res = 1.0;
  for(int i = 0; i < exp; i++) {
    res *= x;
  }
  return res;
}

int main() {
  cout << "2.0 ^ 2 = " << pow(2.0, 2) << endl;
  return 0;
}
```

## C++ STL Library

âœ… [Modern C++: The C++ STL Library (Lecture 4, I. Vizzo, 2020)](https://www.youtube.com/watch?v=T2ZwqdwHRxg&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=10)

### Size of container (C vs. CPP)

```c
int data[6];
size_t data_size = sizeof(data) / sizeof(data[0]);
```

```cpp
std::array<int, 6> data_{};
cout << data_.size() << endl;
```

### Clear elements (C vs. CPP)

```c
char letters[5] = {'a', 'e', 'i', 'o', 'u'};
memset(letters, 0, sizeof(letters));
```

```cpp
std::string letters_{"aeiou"};
letters_.clear();
```

### Iterating over maps

> New in C++17

```cpp
std::map<char, int> _dict{{'a', 17}, {'b', 3}};
for(const auto& [key, val] : _dict) {
    cout << key << val;
}
```

### C++ Iterators

![image-20250118150754948](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202501181508116.png)

### C++ Algorithm

- `sort(v.begin(), v.end())`
- `find(v.begin(), v.end(), val)`
- `fill(v.begin(), v.end(), -1)`
- `count(v.begin(), v.end(), val)`
- `count_if(v.begin(), v.end(), [](int x) {return x % 3 == 0;})`
- `for_each(v.begin(), v.end(), [](const int& n) {cout << " " << n;})`
- ` rotate(v.begin(), v.begin() + 2, v.end())`
- `transform(v.begin(), v.end(), [](char ch) { return std::toupper(ch); })`
- `accumulate(v.begin(), v.end(), 0)`
- `max()`
- `min_element(v.begin(), v.end())`: `*min_element(v.begin(), v.end())`
- `auto [min, max] = minmax_element(v.begin(), v.end())`
- ...

## C++ Utilities

âœ… [Modern C++: I/O Files, Intro to Classes (Lecture 5, I. Vizzo, 2020)](https://www.youtube.com/watch?v=8IHAwmbUuKU&list=PLgnQpQtFTOGRM59sr3nSL8BmeMZR9GCIA&index=11)

C++ includes a variety of utility libraries that provide functionality ranging from bit-counting to partial function application.

These libraries can be broadly divided into two groups:

- language support libraries
- general-purpose libraries

### Language support

Type supportï¼ˆ`std::size_t`ï¼‰

Dynamic memory managementï¼ˆ`std::shared_ptr`ï¼‰

Error handlingï¼ˆ`std::exception`ï¼Œ`assert`ï¼‰

Initializer listï¼ˆ`std::vector{1, 2}`ï¼‰

Much more ...

### General-purpose libraries

Program utilitiesï¼ˆ`std::abort`ï¼‰

Date and Timeï¼ˆ`std::chronologically::duration`ï¼‰

Optional, variant and anyï¼ˆ`std::variant`ï¼‰

Pairs and tuplesï¼ˆ`std::tuple`ï¼‰

Swap, forward and moveï¼ˆ`std::move`ï¼‰

Hash supportï¼ˆ`std::hash`ï¼‰

Formatting library (coming in C++20)

Much more ...

### Much more utilities

Just spend some time looking around: https://en.cppreference.com/w/cpp/utility

## Error handling

> è·³è¿‡ï¼Œä¸å»ºè®®ä½¿ç”¨

We can `throw` an exception if there is an error.

`std::exception`

To use exceptions: `#include <stdexcept>`

An exception can be "caught" at any point of the program (`try - catch`) and even  "thrown" further (`throw`)

The constructor of an exception receives a string error message as a parameter.

This string can be called through a member function `what()`

> Intuition

Only used for "exceptional behavior"

Often misused: e.g. wrong parameter should not lead to an exception.

ğŸ”¥ **GOOGLEâ€”STYLE**: Don't use exceptions.

Link: https://en.cppreference.com/w/cpp/error

## I/O Library

### read/write file

Use streams from STL

Syntax similar to `cerr`, `cout`

```cpp
#include <fstream>

using std::string;
using Mode = std::ios_base::openmode;

// input
std::ifstream f_in(string& filename, Mode mode);

// output
std::ofstream f_out(string& filename, Mode mode);

// in_output
std::fstream f_in_out(string& filename, Mode mode);
```

There are many modes under which a file can be opened.

| Mode             | Meaning                     |
| ---------------- | --------------------------- |
| ios_base::app    | append output               |
| ios_base::ate    | seek to EOF when opened     |
| ios_base::binary | open file in binary mode    |
| ios_base::in     | open file for reading       |
| ios_base::out    | open file for writing       |
| ios_base::trunc  | overwrite the existing file |

```cpp
#include <fstream>
#include <iostream>
#include <string>

using namespace std;

int main() {
  int i;
  double a, b;
  string s;
  ifstream in("test_cols.txt", ios_base::in);
  while (in >> i >> a >> s >> b) {
    // ...
  }
  return 0;
}
```

```cpp
#include <iomanip>
#include <fstream>
using namespace std;
int main() {
    string filename = "out.txt";
    ofstream outfile(filename);
    if(!outfile.is_open()) {
        return EXIT_FAILURE;
    }
    double a = 1.23456789;
    outfile << fixed << setprecision(20) << a << endl;
    return 0;
}
```

### directory_iterator

```cpp
#include <filesystem>
#include <fstream>
#include <iostream>

namespace fs = std::filesystem;

int main() {
  fs::create_directories("sandbox/a/b");
  std::ofstream("sandbox/file1.txt");
  std::ofstream("sandbox/file2.txt");
  for (auto& p : fs::directory_iterator("sandbox")) {
    std::cout << p.path() << "\n";
  }
  fs::remove_all("sandbox");
  return 0;
}
```

```shell
# å¿…é¡»æŒ‡å®š c++ 17 æ‰å¯ä»¥ç¼–è¯‘
g++ -std=c++17 test.cpp -o test
```

```
"sandbox/a"
"sandbox/file1.txt"
"sandbox/file2.txt"
```

---

```cpp
#include <filesystem>
#include <fstream>
#include <iostream>

namespace fs = std::filesystem;

int main() {
  std::cout << fs::path("/foo/bar/txt").filename() << '\n'
            << fs::path("/foo/.bar").filename() << '\n'
            << fs::path("/foo/bar/").filename() << '\n'
            << fs::path("/foo/.").filename() << '\n'
            << fs::path("/foo/..").filename() << '\n';
  return 0;
}
```

```shell
# å¿…é¡»æŒ‡å®š c++ 17 æ‰å¯ä»¥ç¼–è¯‘
g++ -std=c++17 test.cpp -o test
```

```
"txt"
".bar"
""
"."
".."
```

---

```cpp
#include <filesystem>
#include <fstream>
#include <iostream>

namespace fs = std::filesystem;

int main() {
  std::cout << fs::path("/foo/bar.txt").extension() << '\n'
            << fs::path("/foo/bar.").extension() << '\n'
            << fs::path("/foo/bar.png").extension() << '\n'
            << fs::path("/foo/.").extension() << '\n'
            << fs::path("/foo/..").extension() << '\n';
  return 0;
}
```

```shell
g++ -std=c++17 test.cpp -o test
```

```
".txt"
"."
".png"
""
""
```

---

```cpp
const fs::path& p = "...";
fs::(exists(p));
```

## C++ Classes

class glossary

- Class Definition
- Class Implementation
- Class data members
- Class Member functions
- Class Constructors
- Class Destructor
- Class setters
- Class getters
- Class operators
- Class static members

By default everything is `private`

Access members with a "."

**GOOGLEâ€”STYLE**: All data must be `private`

## What about structs?

Definition starts with the keyword `struct`:

```cpp
struct ExampleStruct {
    Type value;
    Type value;
    Type value;
    // No functions!
}
```

`struct` is a `class` where everything is `public`

ğŸ”¥ **GOOGLEâ€”STYLE**: Use `struct` as a simple data container, if it needs a function it should be a `class` instead.

ğŸ”¥ Always initialize structs using braced initialization, such as:

```cpp
struct namedInt {
	int num;
    std::string name;
};

namedInt var{1, std::string{"hello"}};
```

## Const correctness

`const` after function states that this function **does not change the object**

Mark all functions that **should not** change the state of the object as `const`

Ensures that we can pass objects by a `const` reference and still call their functions.

Substantially reduces number of errors.

> Typical const error

```cpp
#include <iostream>
#include <string>

using namespace std;

class Student {
 public:
  Student(string name) : name_(name) {}

  // This function *might* change the object
  const string& getName() { return name_; }
  // correct: const string& getName() const { return name_; }

 private:
  string name_;
};

void Print(const Student& student) { cout << student.getName() << endl; }
```

å¦‚æœä¸åœ¨ getName() åé¢åŠ ä¸Š `const`ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¸èƒ½ä¿è¯ä½ ä¸ä¼šæ”¹å˜å®ƒï¼Œé™¤äº† setterï¼Œä¸€èˆ¬éƒ½éœ€è¦åŠ ä¸Š constå—ï¼Œè¿™èƒ½å¾ˆå¤§ç¨‹åº¦ä¸Šé¿å…é”™è¯¯ã€‚

## `std::Move()` semantics

> c++11 å¼•å…¥ move()

æ‰€æœ‰æƒè½¬ç§»ï¼Œç”¨äºå°†å·¦å€¼æ˜¾ç¤ºè½¬æ¢ä¸ºå³å€¼ï¼Œå…è®¸é€šè¿‡ç§»åŠ¨ï¼ˆè€Œä¸æ˜¯å¤åˆ¶ï¼‰èµ„æºæ¥ä¼˜åŒ–æ€§èƒ½ã€‚

## Smart pointers

- Smart pointers wrap a raw pointer into a class and manage its lifetime (**RAII**)
- Smart opinters are all about ownership
- **Only use them with heap memory!**
- `#include <memory>`

### C++ 11 Smart pointers types

- `std::auto_ptr`
- ğŸ”¥ `std::unique_ptr`
- ğŸ”¥ `std::shared_ptr`
- `std::weak_ptr`

> å› ä¸ºä½¿ç”¨çš„æ˜¯ uniqueï¼Œä¸èƒ½ç›´æ¥ç”¨ = å¤åˆ¶ï¼Œä½†æ˜¯å¯ä»¥è½¬ç§»æ‰€æœ‰æƒï¼Œé‚£å°±ä½¿ç”¨ `move()`

![image-20250118182925534](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202501181829054.png)
