---
title: å…«è‚¡æ–‡ @ é¢è¯•æ‰‹æ’•
description: è®°å½•é¢ç»é«˜é¢‘æ‰‹æ’•é¢˜ï¼Œå®æ—¶æ›´æ–°ä¸­...
publishDate: 2025-08-23
tags: [ç§‹æ‹›æŒ‡å—]
heroImage: { src: ../_img/20250823-TTIoIL.png }
language: Chinese
comment: true
draft: false
---

## 415. å¤§æ•°ç›¸åŠ 

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCode: [415. å­—ç¬¦ä¸²ç›¸åŠ ](https://leetcode.cn/problems/add-strings/)

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²å½¢å¼çš„éè´Ÿæ•´æ•° `num1` å’Œ `num2` ï¼Œè®¡ç®—å®ƒä»¬çš„å’Œå¹¶åŒæ ·ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å›ã€‚

ä½ ä¸èƒ½ä½¿ç”¨ä»»ä½•å…§å»ºçš„ç”¨äºå¤„ç†å¤§æ•´æ•°çš„åº“ï¼ˆæ¯”å¦‚ `BigInteger`ï¼‰ï¼Œ ä¹Ÿä¸èƒ½ç›´æ¥å°†è¾“å…¥çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°å½¢å¼ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnum1 = "11", num2 = "123"
è¾“å‡ºï¼š"134"
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnum1 = "456", num2 = "77"
è¾“å‡ºï¼š"533"
```

1ï¸âƒ£ è§£æ³•ä¸€ï¼šå¯¹ä½æ•°è¾ƒçŸ­çš„æ•°å­—è¿›è¡Œäº†è¡¥é›¶æ“ä½œï¼ˆé¢„å¤„ç†ï¼‰ï¼šself-AC

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int m = num1.length(), n = num2.length();
        int len = abs(m - n);
        string zero(len, '0');
        if (m < n)
            num1 = zero + num1;
        else if (m > n)
            num2 = zero + num2;
        int mx = max(m, n);
        int remain = 0;
        string ans;
        // cout << num1 << ", " << num2 << endl;
        for (int i = mx - 1; i >= 0 || remain; i--) {
            if (i < 0 && remain) {
                ans.push_back('1');
                break;
            }
            char ch = num1[i] + (num2[i] - '0') + remain;
            if (ch > '9') {
                ch = ch - 10;
                remain = 1;
            } else {
                remain = 0;
            }
            ans.push_back(ch);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

2ï¸âƒ£ è§£æ³•äºŒï¼šå»é™¤é¢„å¤„ç†çš„è¿‡ç¨‹ï¼Œç›´æ¥æ¨¡æ‹Ÿ

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        string ans = "";
        while (i >= 0 || j >= 0 || add) {
            int x = i >= 0 ? num1[i] - '0' : 0;
            int y = j >= 0 ? num2[j] - '0' : 0;
            int result = x + y + add;
            ans.push_back('0' + result % 10);
            add = result / 10;
            i--;
            j--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

## 43. å¤§æ•°ç›¸ä¹˜

> å°é¹æ±½è½¦æ™ºé©¾ä¸€é¢

âœ… LeetCode: [43. å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode.cn/problems/multiply-strings/)

ç»™å®šä¸¤ä¸ªä»¥å­—ç¬¦ä¸²å½¢å¼è¡¨ç¤ºçš„éè´Ÿæ•´æ•° `num1` å’Œ `num2`ï¼Œè¿”å› `num1` å’Œ `num2` çš„ä¹˜ç§¯ï¼Œå®ƒä»¬çš„ä¹˜ç§¯ä¹Ÿè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²å½¢å¼ã€‚

**æ³¨æ„ï¼š**ä¸èƒ½ä½¿ç”¨ä»»ä½•å†…ç½®çš„ BigInteger åº“æˆ–ç›´æ¥å°†è¾“å…¥è½¬æ¢ä¸ºæ•´æ•°ã€‚

**ç¤ºä¾‹ 1:**

```
è¾“å…¥: num1 = "2", num2 = "3"
è¾“å‡º: "6"
```

**ç¤ºä¾‹ 2:**

```
è¾“å…¥: num1 = "123", num2 = "456"
è¾“å‡º: "56088"
```

1ï¸âƒ£ è§£æ³•ä¸€æ€è·¯ï¼ˆç«–å¼ç›¸åŠ ï¼‰ï¼šå»ºç«‹åœ¨ã€Œå¤§æ•°ç›¸åŠ ã€çš„åŸºç¡€ä¸Šï¼Œå› ä¸ºå¤šä¸ªæ•°ä¹‹é—´éœ€è¦ç´¯åŠ ï¼ˆè¿™æ®µä»£ç è‡ªå·± AC çš„ï¼Œå®¹æ˜“ç†è§£ï¼‰

![fig1](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202502282147715.png)

```cpp
class Solution {
public:
    // å¤§æ•°ç›¸åŠ 
    string addStrings(string num1, string num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        string ans = "";
        while (i >= 0 || j >= 0 || add) {
            int x = i >= 0 ? num1[i] - '0' : 0;
            int y = j >= 0 ? num2[j] - '0' : 0;
            int result = x + y + add;
            add = result / 10;
            ans.push_back('0' + result % 10);
            i--;
            j--;
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }

    // å¤§æ•°ç›¸ä¹˜
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0")
            return "0";
        int multiply = 0;
        int m = num1.length(), n = num2.length();
        string ans = "0";
        for (int i = m - 1; i >= 0; i--) {
            int x = num1[i] - '0';
            string num;
            int add = 0;
            for (int j = n - 1; j >= 0 || add; j--) {
                if (x == 0) {
                    num = "0";
                    break;
                }
                if (j < 0) {
                    num.push_back('0' + add);
                    break;
                }
                int y = num2[j] - '0';
                int result = x * y + add;
                add = result / 10;
                num.push_back('0' + result % 10);
            }
            reverse(num.begin(), num.end());
            if (num != "0")
                ans = addStrings(ans, num + string(multiply, '0'));
            multiply++;
        }
        return ans;
    }
};
```

2ï¸âƒ£ è§£æ³•äºŒï¼šç›´æ¥åšä¹˜æ³•ï¼Œé•¿åº¦åˆ†åˆ«ä¸º `m` å’Œ `n` çš„æ•°å­—ç›¸ä¹˜ï¼Œå€¼é•¿åº¦ä¸è¶…è¿‡ `m + n`ï¼Œ`vector<int> ansArr(m + n)`

![](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202502282211768.png)

```cpp
/**	 	E x a m p l e
 *
 *               9   9   9
 *         Ã—     6   7   8
 *  ----------------------
 *              72  72  72
 *          63  63  63
 *      54  54  54
 *  ----------------------
 *      54 117 189 135  72
 *  ----------------------
 *      54 117 189 142   2
 *  -----------------------
 *      54 117 203   2   2
 *  -----------------------
 *      54 137   3   2   2
 *  -----------------------
 *      67   7   3   2   2
 *  -----------------------
 *   6   7   7   3   2   2
 */
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") {
            return "0";
        }
        int m = num1.length(), n = num2.length();
        vector<int> ansArr(m + n);
        for (int i = m - 1; i >= 0; i--) {
            int x = num1[i] - '0';
            for (int j = n - 1; j >= 0; j--) {
                int y = num2[j] - '0';
                ansArr[i + j + 1] += x * y;
            }
        }
        for (int i = m + n - 1; i > 0; i--) {
            ansArr[i - 1] += ansArr[i] / 10;
            ansArr[i] %= 10;
        }
        int idx = ansArr[0] == 0 ? 1 : 0;
        string ans;
        while (idx < m + n) {
            ans.push_back('0' + ansArr[idx]);
            idx++;
        }
        return ans;
    }
};
```

## 239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCode: [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º `k` çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ `k` ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚

è¿”å› *æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼* ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums = [1,3,-1,-3,5,3,6,7], k = 3
è¾“å‡ºï¼š[3,3,5,5,6,7]
è§£é‡Šï¼š
æ»‘åŠ¨çª—å£çš„ä½ç½®                æœ€å¤§å€¼
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

1ï¸âƒ£ ä¼˜å…ˆé˜Ÿåˆ— `priority_queue`ï¼ˆè®°å½•æœ€å¤§å€¼ï¼‰ + å“ˆå¸Œè¡¨ï¼ˆè®°å½•åˆ é™¤å…ƒç´ ï¼‰ï¼šself-AC

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, less<int>> pq;
        int n = nums.size();
        unordered_map<int, int> cnt;
        for (int i = 0; i < k; i++)
            pq.push(nums[i]);
        vector<int> ans{pq.top()};
        for (int i = k; i < n; i++) {
            cnt[nums[i - k]]++;
            pq.push(nums[i]);
            while (pq.size() > k && cnt[pq.top()] > 0) {
                cnt[pq.top()]--;
                pq.pop();
            }
            ans.push_back(pq.top());
        }
        return ans;
    }
};
```

2ï¸âƒ£ ä¼˜å…ˆé˜Ÿåˆ— `priority_queue<pair<int, int>>`ï¼Œé€šè¿‡è®°å½•ç´¢å¼•å€¼åˆ¤æ–­ `pq.top()` å…ƒç´ æ˜¯å¦åœ¨å®šé•¿çª—å£å†…

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> pq;
        for (int i = 0; i < k; i++) {
            pq.emplace(nums[i], i);
        }
        vector<int> ans{pq.top().first};
        for (int i = k; i < nums.size(); i++) {
            pq.emplace(nums[i], i);
            while (pq.top().second < i - k + 1) {
                pq.pop();
            }
            ans.push_back(pq.top().first);
        }
        return ans;
    }
};
```

## 206. åè½¬é“¾è¡¨

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCode: [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

> ç›¸å…³ä¾‹é¢˜ â€”â€” [92. åè½¬é“¾è¡¨ II](https://leetcode.cn/problems/reverse-linked-list-ii/)ï¼šåè½¬éƒ¨åˆ†åŒºé—´ï¼Œæ‰¾åˆ°åŒºé—´ `leftNode` ä¸ `rightNode`ï¼Œä»¥åŠ `leftNode` å·¦èŠ‚ç‚¹ `pre` ä¸ `rightNode` å³èŠ‚ç‚¹ `nxt`ï¼Œç‹¬ç«‹åŒºé—´ï¼ˆæ–­å¼€è¿æ¥ï¼‰ååè½¬å†æ¥å›ã€‚
>

ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
è¾“å…¥ï¼šhead = [1,2,3,4,5]
è¾“å‡ºï¼š[5,4,3,2,1]
```

1ï¸âƒ£ è§£æ³•ä¸€ï¼šé€’å½’

```cpp
// æ‰‹å†™é“¾è¡¨ï¼ˆLeetCode å·²ç»å®šä¹‰ï¼Œé¢˜ç›®è‹¥éœ€è¦åˆ™è‡ªå·±å®šä¹‰ï¼‰
struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) : val(x), next(next) {};
};

class Solution {
public:
    // é€’å½’
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* new_head = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return new_head;
    }
};
```

2ï¸âƒ£ è§£æ³•äºŒï¼šä¸‰æŒ‡é’ˆè¿­ä»£ï¼ˆ`pre = nullptr, cur = head, nxt = cur->next`ï¼‰

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
```

## 146. LRU ç¼“å­˜

> è…¾è®¯ WXG ä¸€é¢ï½œè…¾è®¯ CSIG ä¸€é¢ï½œè…¾è®¯ PCG ä¸€é¢

> æ®è¯´æ˜¯æ‰€æœ‰é¢è¯•ä¸­å‡ºç°æ¦‚ç‡çš„ No.1

âœ… LeetCode: [146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)ã€[é¢è¯•é¢˜ 16.25. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache-lcci/)

è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ [LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜](https://baike.baidu.com/item/LRU) çº¦æŸçš„æ•°æ®ç»“æ„ã€‚

å®ç° `LRUCache` ç±»ï¼š

- `LRUCache(int capacity)` ä»¥ **æ­£æ•´æ•°** ä½œä¸ºå®¹é‡ `capacity` åˆå§‹åŒ– LRU ç¼“å­˜
- `int get(int key)` å¦‚æœå…³é”®å­— `key` å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` å¦‚æœå…³é”®å­— `key` å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ `value` ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ `key-value` ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ `capacity` ï¼Œåˆ™åº”è¯¥ **é€å‡º** æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚

å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
è¾“å‡º
[null, null, null, 1, null, -1, null, -1, 3, 4]

è§£é‡Š
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // ç¼“å­˜æ˜¯ {1=1}
lRUCache.put(2, 2); // ç¼“å­˜æ˜¯ {1=1, 2=2}
lRUCache.get(1);    // è¿”å› 1
lRUCache.put(3, 3); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 2 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {1=1, 3=3}
lRUCache.get(2);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.put(4, 4); // è¯¥æ“ä½œä¼šä½¿å¾—å…³é”®å­— 1 ä½œåºŸï¼Œç¼“å­˜æ˜¯ {4=4, 3=3}
lRUCache.get(1);    // è¿”å› -1 (æœªæ‰¾åˆ°)
lRUCache.get(3);    // è¿”å› 3
lRUCache.get(4);    // è¿”å› 4
```

LRUCacheï¼šå¾ªç¯åŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨

- å¾ªç¯ï¼šæ–¹ä¾¿è·å–æœ«å°¾èŠ‚ç‚¹è¿›è¡Œ LRU é€å‡º/åˆ é™¤
- åŒå‘é“¾è¡¨
- å“ˆå¸Œè¡¨ï¼šå¿«é€Ÿæ‰¾åˆ° key å¯¹åº”çš„èŠ‚ç‚¹

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503010621556.png)

```cpp
// LRUCache = å¾ªç¯åŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨
class Node {
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LRUCache {
private:
    int capacity;
    Node* dummy;
    unordered_map<int, Node*> key_to_node;

    // åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // åœ¨é“¾è¡¨å¤´æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹
    void push_front(Node* x) {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // è·å– key å¯¹åº”çš„èŠ‚ç‚¹, åŒæ—¶æŠŠè¯¥èŠ‚ç‚¹ç§»åˆ°é“¾è¡¨å¤´éƒ¨
    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) {
            return nullptr;
        }
        Node* node = it->second;
        remove(node);
        push_front(node);
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
        // å¾ªç¯åŒå‘é“¾è¡¨: æ–¹ä¾¿å–æœ«å°¾å€¼è¿›è¡Œåˆ é™¤
        dummy->prev = dummy;
        dummy->next = dummy;
    }

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) {
            node->value = value;
            return;
        }
        node = new Node(key, value);
        key_to_node[key] = node;
        push_front(node);
        if (key_to_node.size() > capacity) {
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node);
            delete back_node;
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

## 460. LFU ç¼“å­˜

> åä¸ºæœºè€ƒ

âœ… LeetCode: [460. LFU ç¼“å­˜](https://leetcode.cn/problems/lfu-cache/)

> ç›¸å…³ä¾‹é¢˜ï¼š[146. LRU ç¼“å­˜](https://leetcode.cn/problems/lru-cache/)

è¯·ä½ ä¸º [æœ€ä¸ç»å¸¸ä½¿ç”¨ï¼ˆLFUï¼‰](https://baike.baidu.com/item/ç¼“å­˜ç®—æ³•)ç¼“å­˜ç®—æ³•è®¾è®¡å¹¶å®ç°æ•°æ®ç»“æ„ã€‚

å®ç° `LFUCache` ç±»ï¼š

- `LFUCache(int capacity)` - ç”¨æ•°æ®ç»“æ„çš„å®¹é‡ `capacity` åˆå§‹åŒ–å¯¹è±¡
- `int get(int key)` - å¦‚æœé”® `key` å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–é”®çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` - å¦‚æœé”® `key` å·²å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶å€¼ï¼›å¦‚æœé”®ä¸å­˜åœ¨ï¼Œè¯·æ’å…¥é”®å€¼å¯¹ã€‚å½“ç¼“å­˜è¾¾åˆ°å…¶å®¹é‡ `capacity` æ—¶ï¼Œåˆ™åº”è¯¥åœ¨æ’å…¥æ–°é¡¹ä¹‹å‰ï¼Œç§»é™¤æœ€ä¸ç»å¸¸ä½¿ç”¨çš„é¡¹ã€‚åœ¨æ­¤é—®é¢˜ä¸­ï¼Œå½“å­˜åœ¨å¹³å±€ï¼ˆå³ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªé”®å…·æœ‰ç›¸åŒä½¿ç”¨é¢‘ç‡ï¼‰æ—¶ï¼Œåº”è¯¥å»é™¤ **æœ€ä¹…æœªä½¿ç”¨** çš„é”®ã€‚

ä¸ºäº†ç¡®å®šæœ€ä¸å¸¸ä½¿ç”¨çš„é”®ï¼Œå¯ä»¥ä¸ºç¼“å­˜ä¸­çš„æ¯ä¸ªé”®ç»´æŠ¤ä¸€ä¸ª **ä½¿ç”¨è®¡æ•°å™¨** ã€‚ä½¿ç”¨è®¡æ•°æœ€å°çš„é”®æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é”®ã€‚

å½“ä¸€ä¸ªé”®é¦–æ¬¡æ’å…¥åˆ°ç¼“å­˜ä¸­æ—¶ï¼Œå®ƒçš„ä½¿ç”¨è®¡æ•°å™¨è¢«è®¾ç½®ä¸º `1` (ç”±äº put æ“ä½œ)ã€‚å¯¹ç¼“å­˜ä¸­çš„é”®æ‰§è¡Œ `get` æˆ– `put` æ“ä½œï¼Œä½¿ç”¨è®¡æ•°å™¨çš„å€¼å°†ä¼šé€’å¢ã€‚

å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚

**ç¤ºä¾‹ï¼š**

```
è¾“å…¥ï¼š
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
è¾“å‡ºï¼š
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

è§£é‡Šï¼š
// cnt(x) = é”® x çš„ä½¿ç”¨è®¡æ•°
// cache=[] å°†æ˜¾ç¤ºæœ€åä¸€æ¬¡ä½¿ç”¨çš„é¡ºåºï¼ˆæœ€å·¦è¾¹çš„å…ƒç´ æ˜¯æœ€è¿‘çš„ï¼‰
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // è¿”å› 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // å»é™¤é”® 2 ï¼Œå› ä¸º cnt(2)=1 ï¼Œä½¿ç”¨è®¡æ•°æœ€å°
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
lfu.get(3);      // è¿”å› 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // å»é™¤é”® 1 ï¼Œ1 å’Œ 3 çš„ cnt ç›¸åŒï¼Œä½† 1 æœ€ä¹…æœªä½¿ç”¨
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
lfu.get(3);      // è¿”å› 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // è¿”å› 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
```

LFU ç¼“å­˜ = å¾ªç¯åŒå‘é“¾è¡¨ + `key_to_node` å“ˆå¸Œè¡¨ + `freq_to_dummy` å“ˆå¸Œè¡¨

![460-2-c.png](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503011758025.png)

```cpp
class Node {
public:
    int key;
    int value;
    int freq = 1; // default
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LFUCache {
private:
    int min_freq;
    int capacity;
    unordered_map<int, Node*> key_to_node;
    unordered_map<int, Node*> freq_to_dummy; // æ¯ä¸ª freq ä»£è¡¨ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹

    // åˆ›æ–°ä¸€ä¸ªæ–°çš„åŒå‘é“¾è¡¨
    Node* new_list() {
        Node* dummy = new Node(); // å“¨å…µèŠ‚ç‚¹
        dummy->prev = dummy;
        dummy->next = dummy;
        return dummy;
    }

    void remove(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void push_front(int freq, Node* node) {
        auto it = freq_to_dummy.find(freq);
        if (it == freq_to_dummy.end()) {
            // pair<iterator, bool> emplace()
            it = freq_to_dummy.emplace(freq, new_list()).first;
        }
        Node* dummy = it->second;
        node->prev = dummy;
        node->next = dummy->next;
        node->prev->next = node;
        node->next->prev = node;
    }

    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) {
            return nullptr;
        }
        Node* node = it->second;
        remove(node);
        Node* dummy = freq_to_dummy[node->freq];
        if (dummy->prev == dummy) { // å¦‚æœè¯¥ freq å¯¹åº”çš„é“¾è¡¨ç§»é™¤ node åä¸ºç©ºæ—¶
            freq_to_dummy.erase(node->freq);
            delete dummy;
            if (min_freq == node->freq) { // node->freq ä¸ºæœ€å°è®°æ•°
                min_freq++;
            }
        }
        push_front(++node->freq, node);
        return node;
    }

public:
    LFUCache(int capacity) : capacity(capacity) {}

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) {
            node->value = value;
            return;
        }
        if (key_to_node.size() == capacity) {
            Node* dummy = freq_to_dummy[min_freq];
            Node* last_node = dummy->prev;
            key_to_node.erase(last_node->key);
            remove(last_node);
            delete last_node;
            if (dummy->prev == dummy) {
                freq_to_dummy.erase(min_freq);
                delete dummy;
            }
        }
        node = new Node(key, value);
        key_to_node[key] = node;
        push_front(1, node);
        min_freq = 1;
    }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

## 560. å’Œä¸º k çš„å­æ•°ç»„

> Momenta ä¸€é¢

âœ… LeetCode: [560. å’Œä¸º K çš„å­æ•°ç»„](https://leetcode.cn/problems/subarray-sum-equals-k/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å›è¯¥æ•°ç»„ä¸­å’Œä¸º `k` çš„å­æ•°ç»„çš„ä¸ªæ•° ã€‚

å­æ•°ç»„æ˜¯æ•°ç»„ä¸­å…ƒç´ çš„è¿ç»­éç©ºåºåˆ—ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums = [1,1,1], k = 2
è¾“å‡ºï¼š2
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums = [1,2,3], k = 3
è¾“å‡ºï¼š2
```

1ï¸âƒ£ å‰ç¼€å’Œ + å“ˆå¸Œè¡¨

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> preSum(n + 1);
        for(int i = 1; i <= n; i++)
            preSum[i] = nums[i - 1] + preSum[i - 1];
        int ans = 0;
        unordered_map<int, int> cnt;
        for(int num : preSum) {
            ans += cnt.contains(num - k) ? cnt[num - k] : 0;
            cnt[num]++;
        }
        return ans;
    }
};
```

## 93. å¤åŸ IP åœ°å€

> è…¾è®¯ PCG ä¸€é¢

âœ… LeetCode: [93. å¤åŸ IP åœ°å€](https://leetcode.cn/problems/restore-ip-addresses/)

**æœ‰æ•ˆ IP åœ°å€** æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº `0` åˆ° `255` ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ `0`ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ `'.'` åˆ†éš”ã€‚

- ä¾‹å¦‚ï¼š`"0.1.2.201"` å’Œ` "192.168.1.1"` æ˜¯ **æœ‰æ•ˆ** IP åœ°å€ï¼Œä½†æ˜¯ `"0.011.255.245"`ã€`"192.168.1.312"` å’Œ `"192.168@1.1"` æ˜¯ **æ— æ•ˆ** IP åœ°å€ã€‚

ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² `s` ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„**æœ‰æ•ˆ IP åœ°å€**ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ `s` ä¸­æ’å…¥ `'.'` æ¥å½¢æˆã€‚ä½  **ä¸èƒ½** é‡æ–°æ’åºæˆ–åˆ é™¤ `s` ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ **ä»»ä½•** é¡ºåºè¿”å›ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šs = "25525511135"
è¾“å‡ºï¼š["255.255.11.135","255.255.111.35"]
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šs = "0000"
è¾“å‡ºï¼š["0.0.0.0"]
```

1ï¸âƒ£ è§£æ³•ä¸€ï¼šå››å±‚å¾ªç¯è¿­ä»£ï¼Œç®€å•æ˜“æ‡‚æš´åŠ›

```cpp
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        int n = s.length();
        vector<string> ans;
        for (int a = 1; a <= 3; a++) {
            for (int b = 1; b <= 3; b++) {
                for (int c = 1; c <= 3; c++) {
                    for (int d = 1; d <= 3; d++) {
                        if (a + b + c + d == n) {
                            int numA = stoi(s.substr(0, a));
                            int numB = stoi(s.substr(a, b));
                            int numC = stoi(s.substr(a + b, c));
                            int numD = stoi(s.substr(a + b + c, d));
                            if (numA <= 255 && numB <= 255 && numC <= 255 && numD <= 255) {
                                string ip = to_string(numA) + "." +
                                            to_string(numB) + "." +
                                            to_string(numC) + "." +
                                            to_string(numD);
                                if (ip.length() == n + 3) {
                                    ans.push_back(ip);
                                }
                            }
                        }
                    }
                }
            }
        }
        return ans;
    }
};
```

2ï¸âƒ£ å›æº¯æ³•ï½œé€’å½’

```cpp
// ä»£ç 1
class Solution {
public:
    vector<string> ans;
    string ip;

    void backtracking(string s, int i, int segment) {
        if (i == s.length() && segment == 4) {
            ip = ip.substr(0, ip.length() - 1);
            ans.push_back(ip);
            return;
        }
        if (segment > 4) {
            return;
        }
        for (int j = 1; j <= 3 && i + j - 1 < s.length(); j++) {
            if (j > 1 && s[i] == '0') {
                return;
            }
            string subIP = s.substr(i, j);
            int numIP = stoi(subIP);
            if (numIP > 255)
                break;
            int len = ip.length();
            ip = ip + subIP + '.';
            backtracking(s, i + j, segment + 1);
            ip = ip.substr(0, len);
        }
    }

    vector<string> restoreIpAddresses(string s) {
        int n = s.length();
        if (n < 4) {
            return {};
        }
        backtracking(s, 0, 0);
        return ans;
    }
};

// ä»£ç 2
class Solution {
public:
    vector<string> ans;
    vector<string> path;

    vector<string> restoreIpAddresses(string s) {
        int n = s.length();
        if (n < 4 || n > 12) {
            return {};
        }

        function<void(int)> dfs = [&](int i) {
            if (i == n && path.size() == 4) {
                string ip = path[0] + "." + path[1] + "." + path[2] + "." + path[3];
                ans.push_back(ip);
                return;
            }
            for (int j = 1; j <= 3 && i + j - 1 < n; j++) {
                string sub = s.substr(i, j);
                if ((j > 1 && s[i] == '0') || stoi(sub) > 255)
                    break;
                path.push_back(sub);
                dfs(i + j);
                path.pop_back();
            }
        };

        dfs(0);

        return ans;
    }
};
```

## 25. K ä¸ªä¸€ç»„åè½¬é“¾è¡¨

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCode: [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

> ç›¸å…³ä¾‹é¢˜ 1ï¼š[24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)
>
> - [è¿­ä»£ï½œå››æŒ‡é’ˆ](https://leetcode.cn/problems/swap-nodes-in-pairs/submissions/604519840/)
>- [é€’å½’ï½œä¸‰æŒ‡é’ˆ](https://leetcode.cn/problems/swap-nodes-in-pairs/submissions/604520846/)
> 
>ç›¸å…³ä¾‹é¢˜ 2ï¼š[206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)
> 
> ç›¸å…³ä¾‹é¢˜ 3ï¼š[92. åè½¬é“¾è¡¨ II](https://leetcode.cn/problems/reverse-linked-list-ii/)
>

ç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œæ¯ `k` ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨ã€‚

`k` æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ `k` çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºã€‚

ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503010320428.jpg)

```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
è¾“å‡ºï¼š[2,1,4,3,5]
```

1ï¸âƒ£ è§£æ³•ä¸€ï¼šåˆ©ç”¨ã€Œ206. åè½¬é“¾è¡¨ã€+ã€Œ92. åè½¬é“¾è¡¨ IIã€å®Œæˆ

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 206. åè½¬é“¾è¡¨
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    // 92. åè½¬é“¾è¡¨ II
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode dummy(0, head);
        ListNode* pre = &dummy;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }
        ListNode* leftNode = pre->next;
        ListNode* rightNode = leftNode;
        for (int i = left; i < right; i++) {
            rightNode = rightNode->next;
        }
        ListNode* nxt = rightNode->next;
        rightNode->next = nullptr;
        reverseList(leftNode);
        pre->next = rightNode;
        leftNode->next = nxt;
        return dummy.next;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        int n = 0;
        ListNode* cur = head;
        while (cur) {
            n++;
            cur = cur->next;
        }
        if (n < k) {
            return head;
        }
        ListNode* new_head = head;
        int times = n / k;
        for (int i = 0; times--; i += k) {
            ListNode* node = reverseBetween(new_head, i + 1, i + k);
            if (i == 0) {
                new_head = node;
            }
        }
        return new_head;
    }
};
```

2ï¸âƒ£ è§£æ³•äºŒï½œ`0x3f`ï¼šä»åè½¬é“¾è¡¨ç›´æ¥åˆ°ã€ŒK ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ã€

![006.jpg](https://pic.leetcode.cn/1669456133-wgksZa-006.jpg)

åè½¬è¿‡ç¨‹åŒã€Œåè½¬é“¾è¡¨ã€ä»£ç ï¼Œä» `while (cur)` å˜æˆ `for (int i = 0; i < k; i++)`ï¼›å…¶æ¬¡æ¯å¤„ç† k ä¸ªä¸€ç»„åï¼ŒèŠ‚ç‚¹ä¹‹é—´éœ€è¦åˆ‡æ¢ï¼ˆğŸŒŸï¼‰ã€‚

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // ç»Ÿè®¡èŠ‚ç‚¹ä¸ªæ•°
        int n = 0;
        for (ListNode* cur = head; cur; cur = cur->next) {
            n++;
        }
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        ListNode* pre = nullptr;
        ListNode* cur = head;
        // k ä¸ªä¸€ç»„å¤„ç†
        for (; n >= k; n -= k) {
            // åŒ [206. åè½¬é“¾è¡¨]
            for (int i = 0; i < k; i++) {
                ListNode* nxt = cur->next;
                cur->next = pre;
                pre = cur;
                cur = nxt;
            }
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
};
```

## 234. å›æ–‡é“¾è¡¨

âœ… LeetCode: [234. å›æ–‡é“¾è¡¨](https://leetcode.cn/problems/palindrome-linked-list/)

> ç›¸å…³ä¾‹é¢˜ï¼š
>
> - [876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹](https://leetcode.cn/problems/middle-of-the-linked-list/)
>- [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
è¾“å…¥ï¼šhead = [1,2,2,1]
è¾“å‡ºï¼štrue
```

å…ˆæ‰¾åˆ°ä¸­é—´èŠ‚ç‚¹ï¼ˆç±» 876 é¢˜ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼‰ï¼Œç„¶ååè½¬ååŠæ®µçš„é“¾è¡¨ï¼ˆ206 é¢˜åè½¬é“¾è¡¨ï¼‰ï¼Œä¹‹åé€ä¸ªæ¯”è¾ƒå³å¯ã€‚

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    // 876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹
    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 206. åè½¬é“¾è¡¨ï½œè¿­ä»£
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }

    // 206. åè½¬é“¾è¡¨ï½œé€’å½’
    ListNode* recursion_reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* new_head = recursion_reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return new_head;
    }

    bool isPalindrome(ListNode* head) {
        // ä¸­é—´èŠ‚ç‚¹ (å¶æ•°åˆ™ä¸ºåä¸€ä¸ªèŠ‚ç‚¹)
        ListNode* middle = middleNode(head);
        ListNode* node = reverseList(middle);
        while (node) {
            if (head->val != node->val) {
                return false;
            }
            head = head->next;
            node = node->next;
        }
        return true;
    }
};
```

## 23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨

> å¿«æ‰‹æœå¹¿æ¨ä¸€é¢

âœ… LeetCode: [23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šlists = [[1,4,5],[1,3,4],[2,6]]
è¾“å‡ºï¼š[1,1,2,3,4,4,5,6]
è§£é‡Šï¼šé“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š
[
  1->4->5,
  1->3->4,
  2->6
]
å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ°ã€‚
1->1->2->3->4->4->5->6
```

1ï¸âƒ£ æœ€å°å †

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        auto cmp = [](const ListNode* a, const ListNode* b) {
            return a->val > b->val;
        };
        // decltype æ¨æ–­è¡¨è¾¾å¼ç±»å‹
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto head : lists) {
            if (head) {
                pq.push(head);
            }
        }
        ListNode dummy{};
        auto cur = &dummy;
        while (!pq.empty()) {
            ListNode* nxt = pq.top();
            pq.pop();
            cur->next = nxt;
            cur = cur->next;
            if (nxt->next) {
                pq.push(nxt->next);
            }
        }
        return dummy.next;
    }
};
```

2ï¸âƒ£ åˆ†æ²»æ³•

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{};
        ListNode* cur = &dummy;
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1;
                list1 = list1->next;
            } else {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2;
        return dummy.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists, int l, int r) {
        if (l == r)
            return lists[l];
        if (l > r)
            return nullptr;
        int m = (l + r) >> 1;
        auto left = mergeKLists(lists, l, m);
        auto right = mergeKLists(lists, m + 1, r);
        return mergeTwoLists(left, right);
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return mergeKLists(lists, 0, lists.size() - 1);
    }
};
```

## 445. ä¸¤æ•°ç›¸åŠ  II

> è…¾è®¯ CDG ä¸€é¢

âœ… LeetCode: [445. ä¸¤æ•°ç›¸åŠ  II](https://leetcode.cn/problems/add-two-numbers-ii/)

> å‰ç½®é¢˜ç›®ï¼š
>
> -  [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode.cn/problems/add-two-numbers/)
> -  [206. åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/)

ç»™ä½ ä¸¤ä¸ª **éç©º** é“¾è¡¨æ¥ä»£è¡¨ä¸¤ä¸ªéè´Ÿæ•´æ•°ã€‚æ•°å­—æœ€é«˜ä½ä½äºé“¾è¡¨å¼€å§‹ä½ç½®ã€‚å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªå­˜å‚¨ä¸€ä½æ•°å­—ã€‚å°†è¿™ä¸¤æ•°ç›¸åŠ ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨ã€‚

ä½ å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°å­—éƒ½ä¸ä¼šä»¥é›¶å¼€å¤´ã€‚

**ç¤ºä¾‹1ï¼š**

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503280909618.png)

```
è¾“å…¥ï¼šl1 = [7,2,4,3], l2 = [5,6,4]
è¾“å‡ºï¼š[7,8,0,7]
```

åè½¬é“¾è¡¨ + ä¸¤æ•°ç›¸åŠ  = ç§’æ€

```cpp
class Solution {
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }
        auto new_head = reverseList(head->next);
        head->next->next = head; // æŠŠä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘è‡ªå·±
        head->next = nullptr; // æ–­å¼€æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„è¿æ¥ï¼Œä¿è¯æœ€ç»ˆé“¾è¡¨çš„æœ«å°¾èŠ‚ç‚¹çš„ next æ˜¯ç©ºèŠ‚ç‚¹
        return new_head;
    }

    // l1 å’Œ l2 ä¸ºå½“å‰éå†çš„èŠ‚ç‚¹ï¼Œcarry ä¸ºè¿›ä½
    ListNode* addTwo(ListNode* l1, ListNode* l2, int carry = 0) {
        if (l1 == nullptr && l2 == nullptr) { // é€’å½’è¾¹ç•Œï¼šl1 å’Œ l2 éƒ½æ˜¯ç©ºèŠ‚ç‚¹
            return carry ? new ListNode(carry) : nullptr; // å¦‚æœè¿›ä½äº†ï¼Œå°±é¢å¤–åˆ›å»ºä¸€ä¸ªèŠ‚ç‚¹
        }
        if (l1 == nullptr) { // å¦‚æœ l1 æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ­¤æ—¶ l2 ä¸€å®šä¸æ˜¯ç©ºèŠ‚ç‚¹
            swap(l1, l2); // äº¤æ¢ l1 ä¸ l2ï¼Œä¿è¯ l1 éç©ºï¼Œä»è€Œç®€åŒ–ä»£ç 
        }
        carry += l1->val + (l2 ? l2->val : 0); // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
        l1->val = carry % 10; // æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªæ•°ä½
        l1->next = addTwo(l1->next, (l2 ? l2->next : nullptr), carry / 10); // è¿›ä½
        return l1;
    }

public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        l1 = reverseList(l1);
        l2 = reverseList(l2); // l1 å’Œ l2 åè½¬åï¼Œå°±å˜æˆã€2. ä¸¤æ•°ç›¸åŠ ã€‘äº†
        auto l3 = addTwo(l1, l2);
        return reverseList(l3);
    }
};
```

## 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

> è…¾è®¯ CSIG ä¸€é¢

âœ… LeetCode: [24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹](https://leetcode.cn/problems/swap-nodes-in-pairs/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503280915893.jpg)

```
è¾“å…¥ï¼šhead = [1,2,3,4]
è¾“å‡ºï¼š[2,1,4,3]
```

å››ä¸ªæŒ‡é’ˆç§’äº†

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head)
            return head;
        ListNode dummy(0, head);
        ListNode* node0 = &dummy;
        ListNode* node1 = head;
        while (node1 && node1->next) {
            ListNode* node2 = node1->next;
            ListNode* node3 = node2->next;
            node2->next = node1;
            node1->next = node3;
            node0->next = node2;
            node0 = node1;
            node1 = node3;
        }
        return dummy.next;
    }
};
```

## 72. ç¼–è¾‘è·ç¦»

> è…¾è®¯ CDG ä¸€é¢

âœ… LeetCode: [72. ç¼–è¾‘è·ç¦»](https://leetcode.cn/problems/edit-distance/)

ç»™ä½ ä¸¤ä¸ªå•è¯ `word1` å’Œ `word2`ï¼Œ *è¯·è¿”å›å°† `word1` è½¬æ¢æˆ `word2` æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•°* ã€‚

ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š

- æ’å…¥ä¸€ä¸ªå­—ç¬¦
- åˆ é™¤ä¸€ä¸ªå­—ç¬¦
- æ›¿æ¢ä¸€ä¸ªå­—ç¬¦

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šword1 = "horse", word2 = "ros"
è¾“å‡ºï¼š3
è§£é‡Šï¼š
horse -> rorse (å°† 'h' æ›¿æ¢ä¸º 'r')
rorse -> rose (åˆ é™¤ 'r')
rose -> ros (åˆ é™¤ 'e')
```

é€’æ¨ï½œæ³¨æ„è¾¹ç•Œåˆå§‹åŒ–å€¼

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length(), n = word2.length();
        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        for (int i = 0; i <= m; i++)
            f[i][0] = i;
        for (int j = 0; j <= n; j++)
            f[0][j] = j;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                f[i + 1][j + 1] = word1[i] == word2[j] ? f[i][j] : min({f[i][j], f[i + 1][j], f[i][j + 1]}) + 1;
            }
        }
        return f[m][n];
    }
};
```

## 4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°

> å­—èŠ‚ AML ä¸€é¢

âœ… LeetCode: [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

ç»™å®šä¸¤ä¸ªå¤§å°åˆ†åˆ«ä¸º `m` å’Œ `n` çš„æ­£åºï¼ˆä»å°åˆ°å¤§ï¼‰æ•°ç»„ `nums1` å’Œ `nums2`ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›è¿™ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ **ä¸­ä½æ•°** ã€‚

ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¸º `O(log (m+n))` ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šnums1 = [1,3], nums2 = [2]
è¾“å‡ºï¼š2.00000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3] ï¼Œä¸­ä½æ•° 2
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šnums1 = [1,2], nums2 = [3,4]
è¾“å‡ºï¼š2.50000
è§£é‡Šï¼šåˆå¹¶æ•°ç»„ = [1,2,3,4] ï¼Œä¸­ä½æ•° (2 + 3) / 2 = 2.5
```

### ğŸ§ åˆ†æ

æœ¬è´¨ä¸Šï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¸¤ä¸ªæœ‰åºæ•°ç»„ä¸­ï¼ŒæŸ¥æ‰¾ç¬¬ k å°çš„æ•°ï¼Œå…¶ä¸­ k =  (m + n) / 2 **å–ä¸Šæ•´**ã€‚

- å¦‚æœ m+n æ˜¯å¥‡æ•°ï¼Œè¿”å›ç¬¬ k å°çš„æ•°ã€‚
- å¦‚æœ m+n æ˜¯å¶æ•°ï¼Œè¿”å›ç¬¬ k å°çš„æ•°å’Œç¬¬ k+1 å°çš„æ•°çš„å¹³å‡å€¼ã€‚

å…ˆä»æœ€æš´åŠ›çš„ã€Œæ’åºã€åšæ³•å¼€å§‹ï¼Œç„¶åè®²è§£ã€ŒåŒæŒ‡é’ˆã€åšæ³•ï¼Œæœ€åè¿‡æ¸¡åˆ°ã€ŒäºŒåˆ†æŸ¥æ‰¾ã€åšæ³•ã€‚

![lc4-1-c.png](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503300510187.png)

![lc4-4-c2.png](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503300507332.png)

![image-20250330050623809](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503300506015.png)

### ğŸ™‹ ç­”ç–‘

![image-20250330050705467](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503300507578.png)

### 1ï¸âƒ£ ç›¸å‘åŒæŒ‡é’ˆï½œå‡åŒ€åˆ†ç»„ï½œå½“æ¡ä»¶ã€Œç¬¬ä¸€ç»„æœ€å¤§å€¼ â‰¤ ç¬¬äºŒç»„æœ€å°å€¼ã€æ»¡è¶³

```cpp
class Solution {
public:
    // ç›¸å‘åŒæŒ‡é’ˆï½œå‡åŒ€åˆ†ç»„ï½œå½“æ¡ä»¶ã€Œç¬¬ä¸€ç»„æœ€å¤§å€¼ <= ç¬¬äºŒç»„æœ€å°å€¼ã€æ»¡è¶³
    // Hot 100 ä¸­æœ€éš¾çš„ä¸€é¢˜
    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
        if (a.size() > b.size())
            swap(a, b);
        int m = a.size(), n = b.size();
        a.insert(a.begin(), INT_MIN);
        b.insert(b.begin(), INT_MIN);
        a.push_back(INT_MAX);
        b.push_back(INT_MAX);

        int i = 0, j = (m + n + 1) / 2;
        while (true) {
            if (a[i] <= b[j + 1] && b[j] <= a[i + 1]) {
                int max1 = max(a[i], b[j]);         // ç¬¬ä¸€ç»„æœ€å¤§å€¼
                int min2 = min(a[i + 1], b[j + 1]); // ç¬¬äºŒç»„æœ€å°å€¼
                return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
            }
            i++;
            j--;
        }
    }
};
```

### 2ï¸âƒ£ ç”¨äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–ï¼š ç”±äºæ»¡è¶³ç‚¹åªæœ‰ä¸€ä¸ª, æ‰€ä»¥åˆ¤æ–­æ¡ä»¶ä¸º $a[i] â‰¤ b[j + 1]$

```cpp
class Solution {
public:
    // äºŒåˆ†ä¼˜åŒ–, ç”±äºæ»¡è¶³ç‚¹åªæœ‰ä¸€ä¸ª, æ‰€ä»¥åˆ¤æ–­æ¡ä»¶ä¸º a[i] <= b[j + 1]
    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
        if (a.size() > b.size())
            swap(a, b);
        int m = a.size(), n = b.size();
        a.insert(a.begin(), INT_MIN);
        b.insert(b.begin(), INT_MIN);
        a.push_back(INT_MAX);
        b.push_back(INT_MAX);

        int left = 0, right = m + 1;
        while (left + 1 < right) {
            int i = (left + right) / 2;
            int j = (m + n + 1) / 2 - i;
            if (a[i] <= b[j + 1]) {
                left = i;
            } else {
                right = i;
            }
        }

        // left == right - 1
        int i = left;
        int j = (m + n + 1) / 2 - i;
        int max1 = max(a[i], b[j]);
        int min2 = min(a[i + 1], b[j + 1]);
        return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
    }
};
```

## 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ 

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCodeï¼š[230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ ](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ `k` å°çš„å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202504112354266.jpg)

```
è¾“å…¥ï¼šroot = [3,1,4,null,2], k = 1
è¾“å‡ºï¼š1
```

1ï¸âƒ£ ä¸­åºéå†ï¼šåœ¨ä¸­åºéå†ï¼Œå³ã€Œå·¦-æ ¹-å³ã€çš„è¿‡ç¨‹ä¸­ï¼Œæ¯æ¬¡é€’å½’å®Œå·¦å­æ ‘ï¼Œå°±æŠŠ k å‡å°‘ 1ï¼Œè¡¨ç¤ºæˆ‘ä»¬æŒ‰ç…§ä¸­åºéå†è®¿é—®åˆ°äº†ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚æœå‡ä¸€å k å˜æˆ 0ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œç”¨ä¸€ä¸ªå¤–éƒ¨å˜é‡ ans è®°å½•ã€‚

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int ans;
        auto dfs = [&](this auto&& dfs, TreeNode* node) -> void {
            if (node == nullptr) {
                return;
            }
            dfs(node->left); // å·¦
            if (--k == 0) {
                ans = node->val; // æ ¹
            }
            dfs(node->right); // å³
        };
        dfs(root);
        return ans;
    }
};
```

2ï¸âƒ£ ä¸­åºéå†ï¼šç›´æ¥å°†æ‰€æœ‰ç­”æ¡ˆè®°å½•åˆ° vector æ•°ç»„ä¸­ï¼Œè¿”å›å¯¹åº”ç´¢å¼•å€¼å³å¯ã€‚

```cpp
class Solution {
public:
    vector<int> ans;

    void preOrder(TreeNode* node) {
        if (node == nullptr)
            return;
        preOrder(node->left);
        ans.push_back(node->val);
        preOrder(node->right);
    }

    int kthSmallest(TreeNode* root, int k) {
        preOrder(root);
        return ans[k - 1];
    }
};
```

## 354. ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜

> è…¾è®¯ WXG ä¸€é¢

âœ… LeetCodeï¼š[354. ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜](https://leetcode.cn/problems/russian-doll-envelopes/)

ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `envelopes` ï¼Œå…¶ä¸­ `envelopes[i] = [wi, hi]` ï¼Œè¡¨ç¤ºç¬¬ `i` ä¸ªä¿¡å°çš„å®½åº¦å’Œé«˜åº¦ã€‚

å½“å¦ä¸€ä¸ªä¿¡å°çš„å®½åº¦å’Œé«˜åº¦éƒ½æ¯”è¿™ä¸ªä¿¡å°å¤§çš„æ—¶å€™ï¼Œè¿™ä¸ªä¿¡å°å°±å¯ä»¥æ”¾è¿›å¦ä¸€ä¸ªä¿¡å°é‡Œï¼Œå¦‚åŒä¿„ç½—æ–¯å¥—å¨ƒä¸€æ ·ã€‚

è¯·è®¡ç®— **æœ€å¤šèƒ½æœ‰å¤šå°‘ä¸ª** ä¿¡å°èƒ½ç»„æˆä¸€ç»„â€œä¿„ç½—æ–¯å¥—å¨ƒâ€ä¿¡å°ï¼ˆå³å¯ä»¥æŠŠä¸€ä¸ªä¿¡å°æ”¾åˆ°å¦ä¸€ä¸ªä¿¡å°é‡Œé¢ï¼‰ã€‚

**æ³¨æ„**ï¼šä¸å…è®¸æ—‹è½¬ä¿¡å°ã€‚

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šenvelopes = [[5,4],[6,4],[6,7],[2,3]]
è¾“å‡ºï¼š3
è§£é‡Šï¼šæœ€å¤šä¿¡å°çš„ä¸ªæ•°ä¸º 3, ç»„åˆä¸º: [2,3] => [5,4] => [6,7]ã€‚
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼šenvelopes = [[1,1],[1,1],[1,1]]
è¾“å‡ºï¼š1
```

0ï¸âƒ£ DP ä¼šè¶…æ—¶ï¼Œåªèƒ½ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚

1ï¸âƒ£ è´ªå¿ƒ + äºŒåˆ†æŸ¥æ‰¾ï¼šå…ˆæ’åºï¼Œå†æŒ‰ç…§ LIS äºŒåˆ†è´ªå¿ƒæ¨¡æ¿æ±‚æœ€é•¿é€’å¢å­åºåˆ—ã€‚å› ä¸ºäºŒè€…éƒ½å¿…é¡»æ˜¯é€’å¢çš„ï¼Œ**æ‰€ä»¥ç¬¬äºŒç»´åº¦éœ€è¦é€†åºæ’åº**ï¼Œä½¿å¾—ç¬¬ä¸€ç»´åº¦ç›¸åŒçš„å¤šä¸ªæ•°ï¼Œæœ€åä¸€ä¸ªæ’å…¥çš„ä¸€å®šæ˜¯æœ€å°å€¼ï¼Œè¿™æ ·èƒ½åµŒå¥—çš„ä¿¡å°æœ€å¤šã€‚

```cpp
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        sort(envelopes.begin(), envelopes.end(), [](const auto& a, const auto& b) {
            return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);
        });
        vector<int> g;
        for (auto& e : envelopes) {
            auto it = lower_bound(g.begin(), g.end(), e[1]);
            if (it == g.end()) {
                g.push_back(e[1]);
            } else {
                *it = e[1];
            }
        }
        return g.size();
    }
};
```