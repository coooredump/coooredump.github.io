---
title: DuckDB çš„ Adaptive Radix Tree æºç åˆ†æ
description: ART ç´¢å¼•æ˜¯ç”± Viktor Leis, Alfons Kemper, Thomas Neumann ç­‰äººæå‡ºï¼Œå®ƒç›¸æ¯”äº B+ æ ‘çš„ä¸»è¦åŒºåˆ«åœ¨äº B+ æ ‘æ˜¯é¢å‘ç£ç›˜çš„ï¼Œè€Œ ART åˆ™æ˜¯é¢å‘å†…å­˜çš„ï¼Œå³ ART ç´¢å¼•æ˜¯éœ€è¦å…¨éƒ¨åŠ è½½åˆ°å†…å­˜ä¸­ã€‚
publishDate: 2025-03-14
tags: [ç³»ç»Ÿä¸ä½“ç³»ç»“æ„]
heroImage: { src: ../_img/202503140508596.png }
language: Chinese
comment: true
draft: false
---

DuckDB ä¸åŒäºå…¶ä»–æ•°æ®åº“ï¼Œå¹¶æ²¡æœ‰ä½¿ç”¨ B+ æ ‘ä½œä¸ºä¸»è¦ç´¢å¼•ç»“æ„ï¼Œè€Œæ˜¯ä½¿ç”¨ ART (Adaptive Radix Tree) ä½œä¸ºå®ƒå†…éƒ¨çš„ä¸»è¦ç´¢å¼•ç»“æ„ï¼Œæœ¬æ–‡ä»‹ç»è¿™ä¸€ç´¢å¼•ã€‚

## ART (Adaptive Radix Tree)

[ART](https://db.in.tum.de/~leis/papers/ART.pdf) ç´¢å¼•æ˜¯ç”± Viktor Leis, Alfons Kemper, Thomas Neumann ç­‰äººæå‡ºï¼Œå®ƒç›¸æ¯”äº B+ æ ‘çš„ä¸»è¦åŒºåˆ«åœ¨äº **B+ æ ‘æ˜¯é¢å‘ç£ç›˜çš„ï¼Œè€Œ ART åˆ™æ˜¯é¢å‘å†…å­˜çš„**ï¼Œå³ ART ç´¢å¼•æ˜¯éœ€è¦å…¨éƒ¨åŠ è½½åˆ°å†…å­˜ä¸­çš„ã€‚DuckDB ä¹‹æ‰€ä»¥é€‰æ‹©è¿™ä¸ªç´¢å¼•æœ‰ä»¥ä¸‹å‡ æ–¹é¢çš„è€ƒè™‘ï¼š

1. éšç€å†…å­˜è¶Šæ¥è¶Šå¤§ï¼Œå¹¶ä¸”ä»·æ ¼ä¹Ÿè¶Šæ¥è¶Šä¾¿å®œï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨çº¯å†…å­˜çš„ç´¢å¼•ï¼Œä»è€Œé¿å…ç£ç›˜ I/Oï¼Œæå‡æ€§èƒ½
2. ART ç´¢å¼•å¯ä»¥å¾ˆå¤§ç¨‹åº¦ä¸ŠèŠ‚çœç©ºé—´
3. ART ç´¢å¼•æ”¯æŒèŒƒå›´æŸ¥è¯¢
4. ART ç´¢å¼•æœ‰ç€è¾ƒé«˜çš„æ€§èƒ½

åç»­æœ¬æ–‡ä¼šå…ˆä»‹ç» ART è¿™ä¸€æ•°æ®ç»“æ„ï¼Œç„¶åé…åˆç€ DuckDB çš„ä»£ç æè¿° ART æ˜¯å¦‚ä½•å®ç°çš„ã€‚

## Trie æ•°æ®ç»“æ„

åœ¨è®² ART ç´¢å¼•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ Trie æ ‘ğŸŒ²

å¦‚æœä½ ä¸çŸ¥é“ Trie æ ‘ï¼Œå¯ä»¥å‚è€ƒ Wikipediaï¼šhttps://en.wikipedia.org/wiki/Trie

âœ… LeetCode ä¸Šä¹Ÿæœ‰ã€Œ[206. å®ç° Trieï¼ˆå‰ç¼€æ ‘ï¼‰](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)ã€ç®—æ³•é¢˜å¯ä¾›å‚è€ƒï¼š

- è¯·ä½ å®ç° Trie ç±»ï¼š
    - `Trie()` åˆå§‹åŒ–å‰ç¼€æ ‘å¯¹è±¡ã€‚
    - `void insert(String word)` å‘å‰ç¼€æ ‘ä¸­æ’å…¥å­—ç¬¦ä¸² `word` ã€‚
    - `boolean search(String word)` å¦‚æœå­—ç¬¦ä¸² `word` åœ¨å‰ç¼€æ ‘ä¸­ï¼Œè¿”å› `true`ï¼ˆå³ï¼Œåœ¨æ£€ç´¢ä¹‹å‰å·²ç»æ’å…¥ï¼‰ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
    - `boolean startsWith(String prefix)` å¦‚æœä¹‹å‰å·²ç»æ’å…¥çš„å­—ç¬¦ä¸² `word` çš„å‰ç¼€ä¹‹ä¸€ä¸º `prefix` ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

> å‡è®¾å­—ç¬¦ä¸²é‡Œé¢åªæœ‰ a å’Œ b ä¸¤ç§å­—ç¬¦ã€‚
>
> `insert`ï¼šä¾‹å¦‚æ’å…¥å­—ç¬¦ä¸² aabï¼Œç›¸å½“äºç”Ÿæˆäº†ä¸€æ¡ç§»åŠ¨æ–¹å‘ä¸ºã€Œå·¦-å·¦-å³ã€çš„è·¯å¾„ã€‚æ ‡è®°æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸ºç»ˆæ­¢èŠ‚ç‚¹ã€‚å†æ’å…¥å­—ç¬¦ä¸² aabbï¼Œç›¸å½“äºç”Ÿæˆäº†ä¸€æ¡ç§»åŠ¨æ–¹å‘ä¸ºã€Œå·¦-å·¦-å³-å³ã€çš„è·¯å¾„ã€‚æ ‡è®°æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸ºç»ˆæ­¢èŠ‚ç‚¹ã€‚
>
> `search`ï¼šä¾‹å¦‚æŸ¥æ‰¾å­—ç¬¦ä¸² aabï¼Œç›¸å½“äºæŸ¥æ‰¾äºŒå‰æ ‘ä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡ç§»åŠ¨æ–¹å‘ä¸ºã€Œå·¦-å·¦-å³ã€çš„è·¯å¾„ï¼Œä¸”æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯ç»ˆæ­¢èŠ‚ç‚¹ã€‚
>
> `startsWith`ï¼šä¾‹å¦‚æŸ¥æ‰¾å‰ç¼€ aaï¼Œç›¸å½“äºæŸ¥æ‰¾äºŒå‰æ ‘ä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡ç§»åŠ¨æ–¹å‘ä¸ºã€Œå·¦-å·¦ã€çš„è·¯å¾„ï¼Œæ— å…¶ä»–è¦æ±‚ã€‚
>
> ![lc208.png](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140324466.png)
>
> æ¨å¹¿åˆ° 26 ç§å­—æ¯ï¼Œå…¶å®å°±æ˜¯ä¸€æ£µ 26 å‰æ ‘ï¼Œå¯¹äº 26 å‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥ç”¨å“ˆå¸Œè¡¨ï¼Œæˆ–è€…é•¿ä¸º 26 çš„æ•°ç»„æ¥å­˜å‚¨å­èŠ‚ç‚¹ã€‚

```cpp
struct Node {
    Node* son[26]{};
    bool end = false;
};

class Trie {
private:
    Node* root = new Node();

    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                return 0; // not found
            }
            cur = cur->son[c];
        }
        return cur->end ? 2 : 1;
    }

public:
    Trie() {}

    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) {
                cur->son[c] = new Node();
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }

    bool search(string word) {
        return find(word) == 2;
    }

    bool startsWith(string prefix) {
        return find(prefix) != 0;
    }
};
```

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140324242.png)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ° Trie æ ‘åœ¨æ£€ç´¢æ—¶çš„ä¼˜ç‚¹æ˜¯ï¼Œå®ƒçš„æ£€ç´¢æ—¶é—´ä»…ä¸æœ€é•¿çš„å­—ç¬¦ä¸²é•¿åº¦æœ‰å…³ï¼Œè€Œä¸å­˜å‚¨çš„å­—ç¬¦æ•°é‡æ— å…³ï¼Œè¿™ä¸€ç‰¹æ€§åœ¨æ•°æ®é‡æå¤§çš„æƒ…å†µä¸‹ååˆ†ä¼˜ç§€ï¼Œä½†æ˜¯å®ƒçš„ç¼ºç‚¹æ˜¯æµªè´¹ç©ºé—´ï¼Œå³**æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹éƒ½éœ€è¦ä¿å­˜å›ºå®šæ•°é‡çš„æŒ‡é’ˆï¼Œå³ä½¿å®ƒä»…æœ‰æå°‘çš„å­èŠ‚ç‚¹**ã€‚

æ¯”å¦‚å›¾ä¸­çš„ root èŠ‚ç‚¹ï¼Œå°½ç®¡å®ƒåªæœ‰ä¸‰ä¸ªå­èŠ‚ç‚¹ï¼Œä½†æ˜¯å®ƒä»ç„¶éœ€è¦ä¿å­˜æŒ‡å‘ `a,b,c,d,e...` çš„ç©ºæŒ‡é’ˆï¼Œè¿™ååˆ†æµªè´¹ç©ºé—´ï¼Œå…¶æ¬¡ Trie æ ‘ä»…æ”¯æŒä¿å­˜å­—ç¬¦ä¸²ã€‚

ART åˆ™æ˜¯åœ¨ Trie æ ‘çš„åŸºç¡€ä¸Šï¼Œè§£å†³äº†å®ƒç¼ºç‚¹çš„åŒæ—¶ï¼Œä¿ç•™äº†å®ƒçš„ä¼˜ç‚¹ï¼Œä¸‹é¢æ¥ä»‹ç» ART ç´¢å¼•ã€‚

å¯¹äºä¸€ä¸ªç´¢å¼•è€Œè¨€ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒæœ‰ä»¥ä¸‹ä¸¤ä¸ªç‰¹ç‚¹ï¼š

1. æŸ¥è¯¢é€Ÿåº¦å¿«
2. ç©ºé—´å ç”¨å°

ä½†æ˜¯å¦‚æœæˆ‘ä»¬ä½¿ç”¨ Trie æ ‘åšç´¢å¼•ï¼ˆART æ˜¯ Trie çš„ä¸€ä¸ªå˜ç§ï¼‰ï¼Œæˆ‘ä»¬å°±è¦é¢ä¸´å–èˆï¼š

- å¦‚æœå†…éƒ¨èŠ‚ç‚¹æ‹¥æœ‰çš„æœ€å¤§å­èŠ‚ç‚¹è¶Šå¤šï¼ˆç©ºé—´å æ®è¶Šå¤šï¼‰ï¼Œé‚£ä¹ˆå®ƒçš„é«˜åº¦ä¹Ÿè¶Šä½ï¼ˆé€Ÿåº¦è¶Šå¿«ï¼‰
- å¦‚æœå†…éƒ¨èŠ‚ç‚¹æ‹¥æœ‰çš„æœ€å¤§å­èŠ‚ç‚¹è¶Šå°‘ï¼ˆç©ºé—´å æ®è¶Šå°‘ï¼‰ï¼Œé‚£ä¹ˆå®ƒçš„é«˜åº¦ä¹Ÿè¶Šé«˜ï¼ˆé€Ÿåº¦è¶Šæ…¢ï¼‰

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140334359.png)

ART æ ‘é€‰æ‹©æ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹çš„å¤§å°ä¸º 8bitï¼ˆå­èŠ‚ç‚¹çš„æ•°é‡ä¸º 256ï¼‰ï¼Œåˆšå¥½æ˜¯ä¸€ä¸ª `Byte`ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯**å…å»äº†å†…å­˜å¯¹é½çš„é—®é¢˜ï¼ŒåŒæ—¶åœ¨ç©ºé—´ä¸é€Ÿåº¦ä¸Šå–å¾—äº†ä¸€ä¸ªè¾ƒå¥½çš„å¹³è¡¡**ï¼Œæˆ‘ä»¬ç§°å†…éƒ¨èŠ‚ç‚¹æ‰€å æ®çš„ä½å®½ä¸º `span`ã€‚

å°½ç®¡å¦‚æ­¤ï¼Œé¢å¯¹ç¨€ç–çš„æ•°æ®æ—¶ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ 256 ä¸ªå­èŠ‚ç‚¹ä»ç„¶ä¼šæµªè´¹ç©ºé—´ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒART å°†å†…éƒ¨èŠ‚ç‚¹è¿›ä¸€æ­¥ç»†åˆ†ä¸ºä»¥ä¸‹å››ç±»ï¼Œæˆ‘ä»¬åˆ†åˆ«æ¥å¯¹å…¶è¿›è¡Œä»‹ç»ï¼š

- Node 4
- Node 16
- Node 48
- Node 256

### Node 4

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140354857.png)

ä»å›¾ä¸­å¯ä»¥çœ‹å‡ºï¼ŒNode 4 åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯ `key` æ•°ç»„ï¼Œä¸€ä¸ªæ˜¯ `child` æ•°ç»„ã€‚

- `key` æ•°ç»„å­˜æ”¾ key çš„éƒ¨åˆ†å†…å®¹ï¼ˆä¹Ÿå°±æ˜¯ key çš„ä¸€ä¸ª Byteï¼‰
- `child` æ•°ç»„åˆ™æ˜¯ä¿å­˜å¯¹åº”çš„å­èŠ‚ç‚¹çš„æŒ‡é’ˆ

æ³¨æ„ï¼Œæˆ‘ä»¬ä¸ºäº†å¯ä»¥èŒƒå›´æŸ¥è¯¢ï¼Œkey æ•°ç»„è¦æ±‚é¡ºåºå­˜å‚¨ã€‚

### Node 16

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140353397.png)

Node 16 å’Œ Node 4 å‡ ä¹ä¸€æ ·ï¼ŒåŒºåˆ«åªæ˜¯ä» 4 ä¸ª `slot` å˜æˆ 16 ä¸ª `slot`ã€‚

### Node 48

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140401476.png)

Node 48 å’Œä¹‹å‰ä»‹ç»çš„ Node ä¸€æ ·ä¹Ÿæ˜¯åˆ†ä¸º `key` æ•°ç»„å’Œ `child` æ•°ç»„ï¼ŒåŒºåˆ«åœ¨äº Node 48 çš„ `key` æ•°ç»„é•¿åº¦ä¸º 256ï¼Œä¸”**å†…éƒ¨ `key slot` å­˜æ”¾çš„æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘å¯¹åº”å­èŠ‚ç‚¹åœ¨ child æ•°ç»„ä¸­çš„ä½ç½®**ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ— éœ€é€šè¿‡éå†æ‰¾åˆ°å¯¹åº”çš„æ•°ç»„ï¼Œè€Œæ˜¯å¯ä»¥ç›´æ¥é€šè¿‡ key çš„äºŒè¿›åˆ¶å€¼ä½œä¸ºä¸‹æ ‡ç›´æ¥å®šä½åˆ°å¯¹åº”çš„ `key slot`ã€‚

å®é™…æŸ¥è¯¢ä»…éœ€è¦ `child_array[key_array[key]]` å³å¯ã€‚

### Node 256

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140401135.png)

**Node 256 å°±æ˜¯ã€ŒTrie æ ‘ã€åŸå§‹çš„å†…éƒ¨èŠ‚ç‚¹è¡¨ç¤ºå½¢å¼ï¼Œä»…éœ€è¦ä¸€ä¸ªæ•°ç»„**ï¼Œæ•°ç»„çš„ä¸‹æ ‡å³ä¸º keyï¼Œ**æ•°ç»„ä¸­å­˜æ”¾çš„å°±æ˜¯å­èŠ‚ç‚¹çš„æŒ‡é’ˆ**ã€‚

å„ç§ä¸åŒç±»å‹çš„ Node å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œå¦‚æœå­èŠ‚ç‚¹æ•°é‡è¶…è¿‡é™åˆ¶å®¹é‡å°±å‘ä¸Šè½¬æ¢ï¼Œå¦‚æœèŠ‚ç‚¹æ•°é‡ç›¸è¾ƒäºé™åˆ¶å®¹é‡å¤ªå°å°±å‘ä¸‹è½¬æ¢ã€‚

### Leaf

**ART ä¸­çš„å¶èŠ‚ç‚¹å­˜æ”¾çš„å°±æ˜¯ Key å¯¹åº”çš„ Value å€¼**ï¼ŒART çš„å¶èŠ‚ç‚¹å¯ä»¥é‡‡ç”¨ä¸‰ç§å½¢å¼ï¼š

1. å•ç‹¬æœ‰ä¸€ä¸ªå¶èŠ‚ç‚¹ç±»å‹ä¸“é—¨ä¿å­˜ Value
2. å’Œä¸­é—´èŠ‚ç‚¹ä¿æŒä¸€è‡´çš„ç±»å‹ï¼Œå”¯ä¸€åŒºåˆ«åˆ™æ˜¯ child æ•°ç»„ä¸ä¿å­˜æŒ‡é’ˆè€Œæ˜¯ä¿å­˜å€¼
3. å¦‚æœå€¼è¶³å¤Ÿå°å¯ä»¥é€šè¿‡ä½æ“ä½œå’ŒæŒ‡é’ˆä¸€èµ·ä¿å­˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†å€¼ç›´æ¥å­˜æ”¾åœ¨å†…éƒ¨èŠ‚ç‚¹ä¸­

ğŸ”¥ **DuckDB é‡‡ç”¨çš„æ˜¯ç¬¬ä¸€ç§æ–¹å¼**ã€‚

### Optimization

åœ¨è§£å†³äº† ART çš„ç©ºé—´é—®é¢˜ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥**è¿›ä¸€æ­¥ä¼˜åŒ–æŸ¥è¯¢é€Ÿåº¦**ï¼Œå³å‡å°‘æ ‘çš„é«˜åº¦ã€‚

> è®ºæ–‡é“¾æ¥ï¼šhttps://db.in.tum.de/~leis/papers/ART.pdf

è®ºæ–‡ä¸­æœ‰ä¸¤ç§æ–¹å¼ï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ç§ç®€å•çš„åšæ³•åŒæ—¶è·å¾—è¿™ä¸¤ç§ä¼˜åŒ–ï¼Œ**æ¯ä¸ªèŠ‚ç‚¹åŠ ä¸Š Prefix æ ‡è¯†**ã€‚

#### 1. Lazy Expansion

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140409919.png)

å…¶å®è¿™ä¸ªä¼˜åŒ–ç›¸å½“ç®€å•ï¼Œæˆ‘ä»¬åªéœ€ `Leaf` å¯ä»¥ä¿å­˜å¤šä¸ª byte å³å¯ï¼Œè¿™æ ·å­å¯¹äºå¤šä¸ªåªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„è·¯å¾„æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶éƒ½ä¿å­˜åœ¨ `Leaf` ä¸­ï¼Œä»è€Œå‡å°‘æ ‘çš„é«˜åº¦ã€‚

#### 2. Path Compression

è¿™ä¸ªä¼˜åŒ–å’Œ Lazy Expansion ç±»ä¼¼ï¼Œæˆ‘ä»¬åªéœ€è®© `å†…éƒ¨èŠ‚ç‚¹` å¯ä»¥ä¿å­˜å¤šä¸ª byte å³å¯ã€‚å³å¦‚æœå†…éƒ¨èŠ‚ç‚¹æœ‰ç›¸åŒçš„å‰ç¼€ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶ä¿å­˜åœ¨ Prefix ä¸­ï¼Œ`key` æ•°ç»„ä»…ä»…åªå¯¹ key ä¸åŒçš„éƒ¨åˆ†ä½œåŒºåˆ†ã€‚è¿™æ ·ä¹Ÿå¯ä»¥æœ‰æ•ˆåœ°å‡å°‘æ ‘çš„é«˜åº¦ã€‚

å¦‚æœè¿™é‡Œæ²¡çœ‹æ‡‚ä¹Ÿæ²¡å…³ç³»ï¼Œåç»­æˆ‘ä¼šåˆ†æ DuckDB çš„ä»£ç ï¼Œé‚£æ ·ä¼šæ›´åŠ æ¸…æ™°ã€‚

### æ•°æ®è½¬æ¢

å¯¹äº ART æ¥è¯´ï¼Œå‰é¢ä»‹ç»çš„éƒ½æ˜¯å¯¹äºå­—ç¬¦ä¸²ç±»å‹ `string`ï¼Œå¦‚æœä½œä¸ºä¸€ä¸ªå¹¿æ³›ä½¿ç”¨çš„ç´¢å¼•ï¼Œä¹Ÿéœ€è¦æ”¯æŒä¸åŒç±»å‹çš„æ•°æ®ã€‚è€Œ ART ç´¢å¼•å®é™…ä¸Šæ˜¯æŠŠ `Key` ä½œä¸ºæ•°æ®æµè¿›è¡Œå¤„ç†çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœæƒ³è¦é€šè¿‡ ART è¿›è¡ŒèŒƒå›´æœç´¢ï¼Œæˆ‘ä»¬éœ€è¦è®© `Key` ä¿æŒä¸€ä¸ªæ€§è´¨ï¼Œ**å³äºŒè¿›åˆ¶çš„å¤§å°ä¸è¯¥ç±»å‹çš„è¯­ä¹‰å¤§å°ç›¸åŒ**ï¼š
$$
memcmp(binary(x),binary(y)) < 0 \Leftrightarrow x < y \\
memcmp(binary(x),binary(y)) = 0 \Leftrightarrow x = y \\
memcmp(binary(x),binary(y)) > 0 \Leftrightarrow x > y
$$
å› æ­¤æˆ‘ä»¬éœ€è¦å¯¹æŸäº›æ•°å­—è¿›è¡Œè½¬æ¢ã€‚

#### unsigned int

æ— éœ€è½¬åŒ–ï¼Œå·²ç»æ»¡è¶³éœ€æ±‚ã€‚

#### signed int

å°†ç¬¦å·ä¸º `flip` å³å¯ã€‚

#### float

```cpp
static inline uint32_t EncodeFloat(float x) {
	uint64_t buff;

	//! zero
	if (x == 0) {
		buff = 0;
		buff |= (1u << 31);
		return buff;
	}
	// nan
	if (Value::IsNan(x)) {
		return UINT_MAX;
	}
	//! infinity
	if (x > FLT_MAX) {
		return UINT_MAX - 1;
	}
	//! -infinity
	if (x < -FLT_MAX) {
		return 0;
	}
	buff = Load<uint32_t>(const_data_ptr_cast(&x));
	if ((buff & (1u << 31)) == 0) { //! +0 and positive numbers
		buff |= (1u << 31);
	} else {          //! negative numbers
		buff = ~buff; //! complement 1
	}

	return buff;
}
```

#### char

[UCA ç®—æ³•](https://en.wikipedia.org/wiki/Unicode_collation_algorithm)å·²ç»åšå‡ºäº†å®šä¹‰ã€‚

> **Unicode Collation Algorithm** (UCA) æ˜¯ Unicode è§„å®šçš„å¦‚ä½•æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²å¤§å°çš„ç®—æ³•ã€‚

#### null

å¯ä»¥å°†è¯¥å€¼è®¾ç½®ä¸ºæ¯”æœ€å¤§ä½æ•°ä»å¤š 1 ä½ã€‚

#### compound keys

æŒ‰ç…§å…¶åŒ…å«çš„åŸºæœ¬ç±»å‹è¿›è¡Œæ‹¼æ¥å³å¯ã€‚

## DuckDB æºç åˆ†æ

> DuckDB ä»£ç é“¾æ¥ï¼šhttps://github.com/duckdb/duckdb/tree/main/src/execution/index/art
>
> å…¶ä»–å‚è€ƒï¼š
>
> - è®ºæ–‡
>     - ã€ŠThe Adaptive Radix Tree: ARTful Indexing for Main-Memory Databasesã€‹
>     - ã€ŠSMART: A High-Performance Adaptive Radix Tree for Disaggregated Memoryã€‹
> - ç›¸å…³ä»£ç 
>     - [`cpp`] ARTï¼šhttps://github.com/rafaelkallis/adaptive-radix-tree
>     - [`golang`] ARTï¼šhttps://github.com/plar/go-adaptive-radix-tree

è¿™ä¸€ç« é€šè¿‡é˜…è¯» DuckDB çš„æºç ï¼Œæ¥çœ‹ä¸€ä¸‹ ART ç´¢å¼•çš„å®ç°ã€‚

ART ç´¢å¼•çš„ç›¸å…³å®ç°éƒ½åœ¨ `art.cpp` å’Œ `art.hpp`ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ `Insert` å’Œ `Find`ï¼Œå…¶ä»–å‡½æ•°ç•™ç»™è¯»è€…è‡ªè¡Œäº†è§£ã€‚

### Insert

```cpp
bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id) {

	if (!node.IsSet()) {
		// node is currently empty, create a leaf here with the key
		Leaf::New(*this, node, key, depth, row_id);
		return true;
	}

	if (node.DecodeARTNodeType() == NType::LEAF) {

		// add a row ID to a leaf, if they have the same key
		auto &leaf = Leaf::Get(*this, node);
		auto mismatch_position = leaf.prefix.KeyMismatchPosition(*this, key, depth);

		// identical equal
		if (mismatch_position == leaf.prefix.count && depth + leaf.prefix.count == key.len) {
			return InsertToLeaf(node, row_id);
		}

		// example:
		// prefix : hello
		// key[depth] : heel;
		// mismatch_position = 2
		// replace leaf with Node4 and store both leaves in it
		auto old_node = node;
		auto &new_n4 = Node4::New(*this, node);

		// new prefix
		// new_n4's prefix is he
		new_n4.prefix.Initialize(*this, key, depth, mismatch_position);

		// old_node's prefix change to llo
		auto key_byte = old_node.GetPrefix(*this).Reduce(*this, mismatch_position);

		// add child
		Node4::InsertChild(*this, node, key_byte, old_node);

		Node leaf_node;
		Leaf::New(*this, leaf_node, key, depth + mismatch_position + 1, row_id);
		// add child
		Node4::InsertChild(*this, node, key[depth + mismatch_position], leaf_node);

		return true;
	}

	// handle prefix of inner node
	auto &old_node_prefix = node.GetPrefix(*this);
	if (old_node_prefix.count) {

		auto mismatch_position = old_node_prefix.KeyMismatchPosition(*this, key, depth);
		if (mismatch_position != old_node_prefix.count) {

			// prefix differs, create new node
			auto old_node = node;
			auto &new_n4 = Node4::New(*this, node);
			new_n4.prefix.Initialize(*this, key, depth, mismatch_position);

			auto key_byte = old_node_prefix.Reduce(*this, mismatch_position);
			Node4::InsertChild(*this, node, key_byte, old_node);

			Node leaf_node;
			Leaf::New(*this, leaf_node, key, depth + mismatch_position + 1, row_id);
			Node4::InsertChild(*this, node, key[depth + mismatch_position], leaf_node);

			return true;
		}
		depth += node.GetPrefix(*this).count;
	}

	// recurse
	D_ASSERT(depth < key.len);
	auto child = node.GetChild(*this, key[depth]);
	if (child) {
		bool success = Insert(*child, key, depth + 1, row_id);
		node.ReplaceChild(*this, key[depth], *child);
		return success;
	}

	// insert at position
	Node leaf_node;
	Leaf::New(*this, leaf_node, key, depth + 1, row_id);
	Node::InsertChild(*this, node, key[depth], leaf_node);
	return true;
}
```

å‚æ•°å«ä¹‰ï¼š

- `node` å³ä¸ºå½“å‰è¦è¿›è¡Œæ’å…¥çš„èŠ‚ç‚¹
- `key` å³ä¸ºè¦æ’å…¥çš„ key
- `depth`ï¼šå³å½“å‰å·²ç»å¤„ç†åˆ° key çš„ç¬¬å‡ ä¸ª byteï¼Œä¸¾ä¸ªä¾‹å­ï¼Œkey ä¸º `hello`ï¼Œdepth ä¸º 3ï¼Œé‚£ä¹ˆè¯´æ˜ `he` å·²ç»ä¿å­˜åœ¨äº† node çš„ç¥–å…ˆèŠ‚ç‚¹ä¸­ï¼Œæˆ‘ä»¬å½“å‰è¦å¤„ç†çš„æ˜¯ `l`
- `row_id` å³ä¸º key å¯¹åº”çš„ value å€¼

```cpp
bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id) {
	if (!node.IsSet()) {
		// node is currently empty, create a leaf here with the key
		Leaf::New(*this, node, key, depth, row_id);
		return true;
	}
}
```

å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œé‚£ä¹ˆç›´æ¥è®¾ç½®è¯¥èŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹ï¼Œå¹¶ä¸”å°† `row_id` è¿›è¡Œä¿å­˜ï¼Œæ³¨æ„è¿™é‡Œæˆ‘ä»¬ä¼šä½¿ç”¨ `lazy-expansion`ï¼Œå³å°† key å‰©ä½™æœªå¤„ç†çš„å­—ç¬¦å…¨éƒ¨ä¿å­˜åœ¨å¶èŠ‚ç‚¹ä¸­ã€‚

```cpp
bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id) {

	// .... skip
	if (node.DecodeARTNodeType() == NType::LEAF) {

		// add a row ID to a leaf, if they have the same key
		auto &leaf = Leaf::Get(*this, node);
		auto mismatch_position = leaf.prefix.KeyMismatchPosition(*this, key, depth);

		// identical equal
		if (mismatch_position == leaf.prefix.count && depth + leaf.prefix.count == key.len) {
			return InsertToLeaf(node, row_id);
		}

		// example:
		// prefix : hello
		// key[depth] : heel;
		// mismatch_position = 2
		// replace leaf with Node4 and store both leaves in it
		auto old_node = node;
		auto &new_n4 = Node4::New(*this, node);

		// new prefix
		// new_n4's prefix is he
		new_n4.prefix.Initialize(*this, key, depth, mismatch_position);

		// old_node's prefix change to llo
		auto key_byte = old_node.GetPrefix(*this).Reduce(*this, mismatch_position);

		// add child
		Node4::InsertChild(*this, node, key_byte, old_node);

		Node leaf_node;
		Leaf::New(*this, leaf_node, key, depth + mismatch_position + 1, row_id);
		// add child
		Node4::InsertChild(*this, node, key[depth + mismatch_position], leaf_node);

		return true;
	}
	
	//skip....
}
```

å¦‚æœå½“å‰é‡åˆ°çš„æ˜¯å¶èŠ‚ç‚¹ï¼ŒåŒæ—¶ key å®Œå…¨ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥å°† `row_id` æ’å…¥å¶èŠ‚ç‚¹ä¸­ã€‚ä¸ç„¶çš„è¯ï¼Œæˆ‘ä»¬éœ€è¦å°†å¶èŠ‚ç‚¹å˜æˆå†…éƒ¨èŠ‚ç‚¹ï¼ŒåŒæ—¶å°†ä¸åŒçš„éƒ¨åˆ†ä½œä¸ºè¯¥å†…éƒ¨èŠ‚ç‚¹çš„å¶èŠ‚ç‚¹ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140429649.png)

```cpp
bool ART::Insert(Node &node, const ARTKey &key, idx_t depth, const row_t &row_id) {

	// skip ....
	// handle prefix of inner node
	auto &old_node_prefix = node.GetPrefix(*this);
	if (old_node_prefix.count) {

		auto mismatch_position = old_node_prefix.KeyMismatchPosition(*this, key, depth);
		if (mismatch_position != old_node_prefix.count) {

			// prefix differs, create new node
			auto old_node = node;
			auto &new_n4 = Node4::New(*this, node);
			new_n4.prefix.Initialize(*this, key, depth, mismatch_position);

			auto key_byte = old_node_prefix.Reduce(*this, mismatch_position);
			Node4::InsertChild(*this, node, key_byte, old_node);

			Node leaf_node;
			Leaf::New(*this, leaf_node, key, depth + mismatch_position + 1, row_id);
			Node4::InsertChild(*this, node, key[depth + mismatch_position], leaf_node);

			return true;
		}
		depth += node.GetPrefix(*this).count;
	}

	// recurse
	D_ASSERT(depth < key.len);
	auto child = node.GetChild(*this, key[depth]);
	if (child) {
		bool success = Insert(*child, key, depth + 1, row_id);
		node.ReplaceChild(*this, key[depth], *child);
		return success;
	}

	// insert at position
	Node leaf_node;
	Leaf::New(*this, leaf_node, key, depth + 1, row_id);
	Node::InsertChild(*this, node, key[depth], leaf_node);
	return true;
}
```

å¦‚æœæ˜¯å†…éƒ¨èŠ‚ç‚¹ï¼Œé‚£æˆ‘ä»¬éœ€è¦è®¨è®ºï¼š

1. å¦‚æœå‰ç¼€å®Œå…¨ç›¸åŒï¼Œå³ "hello" å’Œ "hellopxxx"ã€‚é‚£ä¹ˆæˆ‘ä»¬ä»…éœ€è¦æ‰¾å‡ºå­èŠ‚ç‚¹è¿›è¡Œæ’å…¥å³å¯

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140432273.png)

2. å¦‚æœå‰ç¼€æœ‰ä¸åŒä¹‹å¤„ï¼Œå³ "hello" å’Œ "helopxxx"ã€‚é‚£ä¹ˆæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œå¹¶å°†ä¸¤ä¸ªèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹è¿›è¡Œæ’å…¥

![img](https://cdn.jsdelivr.net/gh/Wu-yikun/OSS/PicGo/202503140434646.png)

å¯ä»¥çœ‹åˆ°æˆ‘ä»¬åªéœ€è¦åœ¨å†…éƒ¨èŠ‚ç‚¹å’Œå¶èŠ‚ç‚¹ä¸­æ”¯æŒå­˜å‚¨å¤šä¸ªå­—ç¬¦åï¼Œä¾¿å¤©ç„¶æ”¯æŒä¸Šè¿°çš„ä¼˜åŒ–æ–¹æ¡ˆã€‚

### Find

```cpp
Node ART::Lookup(Node node, const ARTKey &key, idx_t depth) {

	while (node.IsSet()) {
		if (node.DecodeARTNodeType() == NType::LEAF) {
			auto &leaf = Leaf::Get(*this, node);

			// check if leaf contains key
			for (idx_t i = 0; i < leaf.prefix.count; i++) {
				if (leaf.prefix.GetByte(*this, i) != key[i + depth]) {
					return Node();
				}
			}
			return node;
		}
		auto &node_prefix = node.GetPrefix(*this);
		if (node_prefix.count) {
			for (idx_t pos = 0; pos < node_prefix.count; pos++) {
				if (key[depth + pos] != node_prefix.GetByte(*this, pos)) {
					// prefix mismatch, subtree of node does not contain key
					return Node();
				}
			}
			depth += node_prefix.count;
		}

		// prefix matches key, but no child at byte, does not contain key
		auto child = node.GetChild(*this, key[depth]);
		if (!child) {
			return Node();
		}

		// recurse into child
		node = *child;
		D_ASSERT(node.IsSet());
		depth++;
	}

	return Node();
}
```

æŸ¥æ‰¾çš„ä»£ç ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•ï¼š

1. æŸ¥æ‰¾åˆ°äº† `Leaf` èŠ‚ç‚¹ï¼Œæ£€æŸ¥ `Prefix` æ˜¯å¦åŒ¹é…ï¼Œå¦‚æœä¸åŒ¹é…è¯´æ˜ Key ä¸å­˜åœ¨ï¼Œè‹¥åŒ¹é…ç›´æ¥è¿”å›è¯¥å¶èŠ‚ç‚¹å³å¯
2. æŸ¥æ‰¾åˆ°äº† `å†…éƒ¨èŠ‚ç‚¹`ï¼Œæ£€æŸ¥ `Prefix` æ˜¯å¦åŒ¹é…ï¼Œå¦‚æœä¸åŒ¹é…è¯´æ˜ Key ä¸å­˜åœ¨ï¼Œè‹¥åŒ¹é…åˆ™ç»§ç»­æœç´¢å¯¹åº”çš„å­èŠ‚ç‚¹

## æœ€å

æœ¬æ–‡ä»‹ç»äº† DuckDB çš„ ART ç´¢å¼•ï¼Œå¯ä»¥çœ‹åˆ°å°½ç®¡ ART ç´¢å¼•çš„æ ‘ä¼šæ¯” B+ æ ‘æ›´é«˜ï¼Œå› æ­¤å¦‚æœæ˜¯é¢å‘ç£ç›˜çš„æƒ…å†µä¸‹ï¼ŒB+ æ ‘ä¼šæ¯” ART ç´¢å¼•ä¼˜åŠ¿æ›´å¤§ï¼Œä½†æ˜¯å¦‚æœæ˜¯å†…å­˜ç´¢å¼•çš„æƒ…å†µä¸‹ï¼ŒART ç´¢å¼•æ›´åŠ ç´§å‡‘ï¼ŒåŒæ—¶å®ƒçš„æ¸è¿›æ—¶é—´å¤æ‚åº¦ä»…ä¸ key çš„é•¿åº¦æœ‰å…³ï¼Œ**å¯èƒ½ä¹Ÿæ›´åŠ  Cache friendly**ï¼Ÿå®ƒçš„èŠ‚ç‚¹ç›¸è¾ƒäº B+ æ ‘æ›´åŠ çš„å°ï¼Œå¯ä»¥æ›´å¤šçš„ä¿å­˜åœ¨ Cache ä¸­ã€‚ä»è®ºæ–‡ä¸­çš„å®éªŒæ¥çœ‹ï¼Œå®ƒçš„æ€§èƒ½ä¼šæ¯” B+ æ ‘æ›´å¥½ã€‚ç›¸è¾ƒäº `Hash table`ï¼Œå®ƒæ”¯æŒèŒƒå›´æŸ¥è¯¢ã€‚åŸºäºæ­¤ï¼ŒDuckDB å°† ART ç´¢å¼•ä½œä¸ºå…¶çš„ä¸»è¦ç´¢å¼•ã€‚