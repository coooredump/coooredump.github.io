---
title: PMDK Programming Guidelines
description: åœ¨ä½¿ç”¨ libpmemobj åº“æ—¶ï¼Œä¸éœ€è¦ç›´æ¥ä½¿ç”¨ mmapã€‚libpmemobj æä¾›äº†é«˜çº§çš„ API æ¥ç®¡ç†æŒä¹…å†…å­˜æ± å’Œåˆ†é…å†…å­˜ã€‚mmap é€šå¸¸ç”¨äºæ›´åº•å±‚çš„å†…å­˜æ˜ å°„æ“ä½œï¼Œè€Œ libpmemobj å°è£…äº†è¿™äº›æ“ä½œï¼Œä½¿å¾—ç®¡ç†æŒä¹…å†…å­˜æ›´åŠ æ–¹ä¾¿å’Œå®‰å…¨ã€‚
publishDate: 2024-12-28
tags: [ç³»ç»Ÿä¸ä½“ç³»ç»“æ„]
heroImage: { src: ../_img/202501222348546.png }
language: Chinese
comment: true
draft: false
---

## libpmemobj

åœ¨ä½¿ç”¨ `libpmemobj` åº“æ—¶ï¼Œä¸éœ€è¦ç›´æ¥ä½¿ç”¨ `mmap`ã€‚`libpmemobj` æä¾›äº†é«˜çº§çš„ API æ¥ç®¡ç†æŒä¹…å†…å­˜æ± å’Œåˆ†é…å†…å­˜ã€‚`mmap` é€šå¸¸ç”¨äºæ›´åº•å±‚çš„å†…å­˜æ˜ å°„æ“ä½œï¼Œè€Œ `libpmemobj` å°è£…äº†è¿™äº›æ“ä½œï¼Œä½¿å¾—ç®¡ç†æŒä¹…å†…å­˜æ›´åŠ æ–¹ä¾¿å’Œå®‰å…¨ã€‚

```cpp
#include <libpmemobj.h>
#include <iostream>
#include <cassert>
#include <cstring>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

void init_pmem() {
    // create pool
    const char *pool_name = "/mnt/pmem0/matianmao/fast_fair.data";
    const char *layout_name = "fast_fair";
    size_t pool_size = 64LL * 1024 * 1024 * 1024; // 16GB

    if (access(pool_name, 0)) {
        pmem_pool = pmemobj_create(pool_name, layout_name, pool_size, 0666);
        if (pmem_pool == nullptr) {
            std::cout << "[FAST FAIR]\tcreate fail\n";
            assert(0);
        }
        std::cout << "[FAST FAIR]\tcreate\n";
    } else {
        pmem_pool = pmemobj_open(pool_name, layout_name);
        std::cout << "[FAST FAIR]\topen\n";
    }
    std::cout << "[FAST FAIR]\topen pmem pool successfully\n";
}

// å‡½æ•°é€šè¿‡ pmemobj_zalloc ä»æŒä¹…å†…å­˜æ± ä¸­åˆ†é…æŒ‡å®šå¤§å°çš„å†…å­˜ï¼Œå¹¶è¿”å›åˆ†é…çš„å†…å­˜åœ°å€
// å¦‚æœåˆ†é…å¤±è´¥ï¼Œè¾“å‡ºé”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢ç¨‹åº
void *allocate(size_t size) {
    // ç”¨äºå­˜å‚¨åˆ†é…çš„å†…å­˜åœ°å€
    void *addr;
    // ç”¨äºå­˜å‚¨æŒä¹…å†…å­˜å¯¹è±¡çš„æ ‡è¯†ç¬¦
    PMEMoid ptr;
    // è°ƒç”¨ pmemobj_zalloc å‡½æ•°ä»æŒä¹…å†…å­˜æ±  pmem_pool ä¸­åˆ†é…å¤§å°ä¸º size å­—èŠ‚çš„å†…å­˜ï¼Œå¹¶å°†åˆ†é…çš„å†…å­˜å¯¹è±¡æ ‡è¯†ç¬¦å­˜å‚¨åœ¨ ptr ä¸­
    int ret = pmemobj_zalloc(pmem_pool, &ptr, sizeof(char) * size, TOID_TYPE_NUM(char));
    if (ret) {
        std::cout << "[FAST FAIR]\tallocate btree successfully\n";
        assert(0);
    }
    // å°†æŒä¹…å†…å­˜å¯¹è±¡æ ‡è¯†ç¬¦ ptr è½¬æ¢ä¸ºç›´æ¥æŒ‡é’ˆï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ addr ä¸­
    addr = (char *)pmemobj_direct(ptr);
    // è¿”å›åˆ†é…çš„å†…å­˜åœ°å€
    return addr;
}
```

1ï¸âƒ£ ä½¿ç”¨ `libpmemobj` åº“å‡½æ•°è¯»å†™æŒä¹…å†…å­˜çš„ç¤ºä¾‹ä»£ç  ***libpmemobj_pmem.cpp***ï¼ˆwithout mmap â€”â€” å°è£…ğŸ“¦å¥½äº†ï¼‰ï¼š

```cpp
#include <libpmemobj.h>
#include <iostream>
#include <cassert>
#include <cstring>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

// æŒä¹…å†…å­˜æ± çš„å…¨å±€å˜é‡
PMEMobjpool *pmem_pool;

// å®šä¹‰æŒä¹…å¯¹è±¡çš„ç±»å‹ç¼–å·
#define TOID_TYPE_NUM_CHAR 1

// åˆå§‹åŒ–æŒä¹…å†…å­˜æ± 
void init_pmem() {
    // æŒä¹…å†…å­˜æ± çš„åç§°å’Œå¸ƒå±€åç§°
    const char *pool_name = "/mnt/pmem1/libpmemobj_pmem";
    const char *layout_name = "fast_fair";
    // æŒä¹…å†…å­˜æ± çš„å¤§å°ï¼ˆ16GBï¼‰
    size_t pool_size = 16LL * 1024 * 1024 * 1024;

    // æ£€æŸ¥æŒä¹…å†…å­˜æ± æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    if (access(pool_name, 0)) {
        // åˆ›å»ºæŒä¹…å†…å­˜æ± 
        pmem_pool = pmemobj_create(pool_name, layout_name, pool_size, 0666);
        if (pmem_pool == nullptr) {
            std::cout << "[FAST FAIR]\tcreate fail\n";
            assert(0);
        }
        std::cout << "[FAST FAIR]\tcreate\n";
    } else {
        // æ‰“å¼€æŒä¹…å†…å­˜æ± 
        pmem_pool = pmemobj_open(pool_name, layout_name);
        if (pmem_pool == nullptr) {
            std::cout << "[FAST FAIR]\topen fail\n";
            assert(0);
        }
        std::cout << "[FAST FAIR]\topen\n";
    }
    std::cout << "[FAST FAIR]\topen pmem pool successfully\n";
}

// åˆ†é…æŒ‡å®šå¤§å°çš„æŒä¹…å†…å­˜ï¼Œå¹¶è¿”å›åˆ†é…çš„å†…å­˜åœ°å€
void *allocate(size_t size) {
    // ç”¨äºå­˜å‚¨åˆ†é…çš„å†…å­˜åœ°å€
    void *addr;
    // ç”¨äºå­˜å‚¨æŒä¹…å†…å­˜å¯¹è±¡çš„æ ‡è¯†ç¬¦
    PMEMoid ptr;
    // è°ƒç”¨ pmemobj_zalloc å‡½æ•°ä»æŒä¹…å†…å­˜æ±  pmem_pool ä¸­åˆ†é…å¤§å°ä¸º size å­—èŠ‚çš„å†…å­˜ï¼Œå¹¶å°†åˆ†é…çš„å†…å­˜å¯¹è±¡æ ‡è¯†ç¬¦å­˜å‚¨åœ¨ ptr ä¸­
    int ret = pmemobj_zalloc(pmem_pool, &ptr, sizeof(char) * size, TOID_TYPE_NUM_CHAR);
    if (ret) {
        std::cout << "[FAST FAIR]\tallocate fail\n";
        assert(0);
    }
    // å°†æŒä¹…å†…å­˜å¯¹è±¡æ ‡è¯†ç¬¦ ptr è½¬æ¢ä¸ºç›´æ¥æŒ‡é’ˆï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ addr ä¸­
    addr = pmemobj_direct(ptr);
    // è¿”å›åˆ†é…çš„å†…å­˜åœ°å€
    return addr;
}

int main() {
    // åˆå§‹åŒ–æŒä¹…å†…å­˜æ± 
    init_pmem();

    // åˆ†é… 1024 å­—èŠ‚çš„æŒä¹…å†…å­˜
    void *pmem_addr = allocate(1024);
    std::cout << "[FAST FAIR]\tallocated 1024 bytes at " << pmem_addr << "\n";

    // ä½¿ç”¨åˆ†é…çš„æŒä¹…å†…å­˜ï¼ˆä¾‹å¦‚ï¼Œå†™å…¥æ•°æ®ï¼‰
    strcpy((char *)pmem_addr, "Hello, Persistent Memory!");
    std::cout << "[FAST FAIR]\tdata written: " << (char *)pmem_addr << "\n";

    // å…³é—­æŒä¹…å†…å­˜æ± 
    pmemobj_close(pmem_pool);
    std::cout << "[FAST FAIR]\tpmem pool closed\n";

    return 0;
}
```

ç¼–è¯‘å‘½ä»¤ï¼š

```sh
$ g++ -o libpmemobj libpmemobj_pmem.cpp -lpmemobj
$ ./libpmemobj
```

## mmap

2ï¸âƒ£ å¦‚æœä¸ä½¿ç”¨ `libpmemobj` åº“å‡½æ•°æ¥è¯»å†™æŒä¹…å†…å­˜ï¼ˆPMï¼‰ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨ `mmap` å‡½æ•°å°†æŒä¹…å†…å­˜æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œç„¶åé€šè¿‡æŒ‡é’ˆæ“ä½œè¿›è¡Œè¯»å†™ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ä»£ç  ***mmap_pmem.cpp***ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `mmap` æ¥è¯»å†™æŒä¹…å†…å­˜ï¼š

```cpp
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <iostream>
#include <cstring>
#include <cassert>

#define PMEM_FILE_PATH "/mnt/pmem1/mmap_pmem"
#define PMEM_FILE_SIZE (16LL * 1024 * 1024 * 1024) // 16GB

void* pmem_addr = nullptr;
int pmem_fd = -1;

// åˆå§‹åŒ–æŒä¹…å†…å­˜
void init_pmem() {
    // æ‰“å¼€æˆ–åˆ›å»ºæŒä¹…å†…å­˜æ–‡ä»¶
    pmem_fd = open(PMEM_FILE_PATH, O_RDWR | O_CREAT, 0666);
    if (pmem_fd < 0) {
        std::cerr << "Failed to open or create PMEM file" << std::endl;
        exit(1);
    }

    // è®¾ç½®æ–‡ä»¶å¤§å°
    if (ftruncate(pmem_fd, PMEM_FILE_SIZE) != 0) {
        std::cerr << "Failed to set PMEM file size" << std::endl;
        close(pmem_fd);
        exit(1);
    }

    // å°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜
    pmem_addr = mmap(nullptr, PMEM_FILE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, pmem_fd, 0);
    if (pmem_addr == MAP_FAILED) {
        std::cerr << "Failed to mmap PMEM file" << std::endl;
        close(pmem_fd);
        exit(1);
    }

    std::cout << "PMEM initialized successfully" << std::endl;
}

// å…³é—­æŒä¹…å†…å­˜
void close_pmem() {
    if (pmem_addr != nullptr) {
        munmap(pmem_addr, PMEM_FILE_SIZE);
        pmem_addr = nullptr;
    }
    if (pmem_fd >= 0) {
        close(pmem_fd);
        pmem_fd = -1;
    }
    std::cout << "PMEM closed successfully" << std::endl;
}

int main() {
    // åˆå§‹åŒ–æŒä¹…å†…å­˜
    init_pmem();

    // åˆ†é… 1024 å­—èŠ‚çš„æŒä¹…å†…å­˜
    void* data_addr = static_cast<char*>(pmem_addr) + 1024;
    std::cout << "Allocated 1024 bytes at " << data_addr << std::endl;

    // ä½¿ç”¨åˆ†é…çš„æŒä¹…å†…å­˜ï¼ˆä¾‹å¦‚ï¼Œå†™å…¥æ•°æ®ï¼‰
    strcpy(static_cast<char*>(data_addr), "Hello, Persistent Memory!");
    std::cout << "Data written: " << static_cast<char*>(data_addr) << std::endl;

    // å…³é—­æŒä¹…å†…å­˜
    close_pmem();

    return 0;
}
```

## pmem_map_file

3ï¸âƒ£ è°ƒç”¨ `pmem_map_file` å‡½æ•°æ¥æ˜ å°„ PMï¼Œ`pmem_map_file` æ˜¯ `libpmem` åº“ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºå°†æŒä¹…å†…å­˜æ–‡ä»¶æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚ç¤ºä¾‹ä»£ç  ***pmem.c*** å¦‚ä¸‹ï¼š

```cpp
#include <fcntl.h>      // for open, O_RDWR, O_CREAT, O_TRUNC
#include <unistd.h>     // for close, ftruncate
#include <sys/types.h>  // for types
#include <sys/stat.h>   // for ftruncate
#include <libpmem.h>    // for PMDK functions
#include <stdio.h>
#include <stdlib.h>

#define PMEM_SIZE 1024
#define PMEM_FILE "/mnt/pmem1/pmem_file"

int main() {
    // åˆ›å»ºæŒä¹…å†…å­˜æ–‡ä»¶
    int fd = open(PMEM_FILE, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd < 0) {
        perror("open");
        return EXIT_FAILURE;
    }
    ftruncate(fd, PMEM_SIZE);

    // æ˜ å°„æŒä¹…å†…å­˜
    void *pmem_addr = pmem_map_file(PMEM_FILE, PMEM_SIZE, PMEM_FILE_CREATE, 0666, NULL, NULL);
    if (pmem_addr == NULL) {
        perror("pmem_map_file");
        return EXIT_FAILURE;
    }

    // å†™å…¥æ•°æ®
    sprintf(pmem_addr, "Hello, Persistent Memory!");

    // åˆ·æ–°æŒä¹…å†…å­˜
    pmem_persist(pmem_addr, PMEM_SIZE);

    // è¯»å–æ•°æ®
    printf("%s\n", (char *)pmem_addr);

    // æ¸…ç†
    pmem_unmap(pmem_addr, PMEM_SIZE);
    close(fd);
    return EXIT_SUCCESS;
}
```

`pmem_map_file` åº•å±‚å°è£…çš„ä¹Ÿæ˜¯ `mmap`ï¼Œä»¥ä¸‹æ˜¯ `pmem_map_file` å®ç°çš„ä¸€ä¸ªç®€åŒ–ç¤ºä¾‹ï¼Œå…·ä½“å®ç°å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒï¼š

> pmdk/src/libpmem/pmem.c ä»£ç åº“ä¸­å¯¹ `pmem_map_file` çš„å®šä¹‰ -- **create or open the file and map it to memory**

```cpp
#include <libpmem.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

void *pmem_map_file(const char *path, size_t len, int flags, mode_t mode, size_t *mapped_lenp, int *is_pmemp) {
    int fd = open(path, flags, mode);
    if (fd < 0) {
        perror("open");
        return NULL;
    }

    if (len == 0) {
        len = lseek(fd, 0, SEEK_END);
        if (len == (size_t)-1) {
            perror("lseek");
            close(fd);
            return NULL;
        }
    }

    void *addr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return NULL;
    }

    close(fd);

    if (mapped_lenp)
        *mapped_lenp = len;
    if (is_pmemp)
        *is_pmemp = 1; // Simplified, actual implementation may check if it's true PMEM

    return addr;
}
```